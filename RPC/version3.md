# V3.0 负载均衡
在之前的版本中，当客户端请求服务时，取 从注册中心返回的服务地址列表中的第一个 作为访问的地址

这样做是明显存在问题的，当请求量过大时，单节点会无法承载庞大的流量从而崩溃。

所以在一些流量较大的服务上，我设置多个节点服务器处理请求，并使用负载均衡的思想 将请求分摊到每个节点上

## 常见负载均衡算法
1. 轮询法
2. 随机法
## 3. 一致性哈希法
 -   **原理**：一致性哈希法将输入（如客户端IP地址）通过哈希函数映射到一个固定大小的环形空间（哈希环）上，每个服务器也映射到这个哈希环上。客户端的请求会根据哈希值在哈希环上顺时针查找，遇到的第一个服务器就是该请求的目标服务器。
    

-   **优点**
    
    -   当服务器数量发生变化时，只有少数键需要被重新映射到新的服务器上，这大大减少了缓存失效的数量，提高了系统的可用性。
        
    
    -   具有良好的可扩展性，可以动态地添加或删除服务器。
        
    

-   **缺点**
    
    -   在哈希环偏斜的情况下，大部分的缓存对象很有可能会缓存到一台服务器上，导致缓存分布极度不均匀。
        
    
    -   实现较为复杂，需要引入虚拟节点等技术来解决哈希偏斜问题。
    - “虚拟节点”就是真实节点的复制品，一个真实的节点对应多个“虚拟节点”，这样使得我们的节点能尽可能的在环形Hash空间均匀分布，这样我们再根据虚拟节点找到真实节点，从而保证每个真实节点上分配到的请求是均衡的。

	- 没有虚拟节点的情况下，节点的增加或删除会导致哈希环上的重新分配，可能导致大量的请求重定向到其他节点，引入虚拟节点后，节点的增删只会影响与该节点相关的少部分虚拟节点，减少了请求的迁移
	- 如果一个真实节点故障且没有虚拟节点，所有映射到该节点的请求都会丢失，引入虚拟节点后，其他的虚拟节点可能会分摊其负载，减少系统的影响

## 为什么使用treeMap存储虚拟节点
TreeMap会根据键的顺序自动进行排序，使用TreeMap存储哈希值与虚拟节点之间的映射时，哈希值会始终保持有序，因为我们需要按照哈希值的大小顺序来查找最近的节点，TreeMap底层通过红黑树实现有序性。当根据请求的哈希值查找该映射到哪个虚拟节点时，可以通过tailMap()方法找到所有大于等于该哈希值的虚拟节点，快速获取到最近的一个虚拟节点

## 当各个服务器的负载能力不一致时，该怎么设置负载均衡算法，来保证各服务器接收到的流量是合适的呢？
在一致性哈希算法中，使用虚拟节点对真实节点进行映射，并且能通过设置虚拟节点的个数 来控制该节点接收到请求的概率。

所以在服务器负载能力不一致的情况下，我们可以在服务端将服务器的负载能力写入到注册中心中，客户端在进行负载均衡时会在注册中心中获取各服务器的能力，并设置对应的虚拟节点的数量，来控制流量的分发。
##  LRU适合作为负载均衡的一个实现吗？
LRU的思想可以被借鉴用于负载均衡。例如可以设计一个基于请求历史的负载均衡算法，其中每个服务器都有一个“最近访问时间戳”，当新的请求到来时，可以选择“最久未被请求”的服务器进行处理。但这种做法通常不是最优的，因为它没有考虑到服务器的当前负载，并且还可能会出现 **部分某个时间被大量访问的节点之后无法再访问到**的问题。

# V3.1 超时重传，白名单
使用Guava Retry实现超时重传
![输入图片说明](/imgs/2025-03-24/UAkQW5exWwKQnJJt.png)
withRetryListener()：设置重试监听器，用来执行额外的处理工作 withWaitStrategy()

##  重试机制存在什么问题？
如果这个服务业务逻辑不是幂等的，比如插入数据操作，则会出现问题
可以设置一个白名单，服务端在注册节点时，将幂等性的服务注册在白名单中，客户端在请求服务前，先去白名单中查看该服务是否为幂等服务，如果是的话使用重试框架进行调用

白名单可以存放在zookeeper中（充当配置中心的角色）

流程
- 初始化标志变量：`canRetry`用于标记该服务是否可以重试，初始值为`false`
- 获取服务白名单：通过Zookeeper客户端（client.getChildren())获取/RETRY路径下的所有子节点，即所有被允许重试的服务名称
- 遍历获取到的服务列表，若查到当前输入的`serviceName`说明服务在白名单中，设置`canRetry = true`
- 返回`canRetry`

注册中心中`client.create().creatingParentsIfNeeded().withMode(CreateMode.EPHEMERAL).forPath(path)`
withMode(CreateMode.EPHEMERAL)表示设置的节点类型为临时节点，当客户端与Zookeeper链接断开后，会自动删除这个节点
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAwMjgxMzMxMSwxOTk5MTE0MDk5LDEyNj
k4NTU2MjUsLTYzNDc2NTIyMiwtOTYzNTE0MjkzLDMxNDcxOTAy
NCwyMTA2MTM2MTQ4LC00NDk1NzE4NTIsLTIwODg3NDY2MTJdfQ
==
-->