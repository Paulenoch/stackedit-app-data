RPC是解决分布式系统通信问题的框架，分布式系统的一大特点是高并发，为保证服务在高访问量、高并发的场景下，依旧稳定和高可用，需要从服务端和调用端进行保护

# V4.0 服务端限流
当调用端发送请求过来时，服务端在执行业务逻辑之前先执行限流逻辑，如果发现访问量过大并且超出了限流的阈值，就让服务端直接抛回给调用端一个限流异常，否则就执行正常的业务逻辑。

常见限流算法：
- 固定窗口计数法：将时间划分为固定大小的窗口，规定每个窗口内的请求上限；优点：简单易实现；缺点：限流不够平滑，无法保证限流速率

- 滑动窗口计数法：例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 `60(请求数)/60（窗口数）` 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。优点：可以应对激增的流量，颗粒度更小限流控制更精准；缺点：基本同上

- 漏桶算法：把发请求的动作比作成注水到桶中，处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。优点：简单可控制限流速率；缺点：无法应对流量激增，若发请求的速率一直高于处理请求的速率，桶一直是满的会导致部分新的请求被丢弃

- 令牌桶算法：桶里装的是令牌，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。优点：可以限制平均速率和应对突然激增的流量。可以动态调整生成令牌的速率。

假设令牌桶最大容量为n，每秒产生r个令牌

平均速率：则随着时间推延，处理请求的平均速率越来越趋近于每秒处理r个请求，说明令牌桶算法可以控制平均速率

瞬时速率：如果在一瞬间有很多请求进来，此时来不及产生令牌，则在一瞬间最多只有n个请求能获取到令牌执行业务逻辑，所以令牌桶算法也可以控制瞬时速率

## 令牌桶算法实现
令牌产生速度`RATE`
桶容量`CAPACITY`
当前桶容量`curCapacity`
时间戳`timeStamp`

`timeStamp`为上一次请求获取令牌的时间，我们没必要真的实现计时器每秒产生多少令牌放入容器中，只要记住上一次请求到来的时间，和这次请求的差值就知道在这段时间内产生了多少令牌

若`curCapacity>0`，直接返回true

若桶无剩余，如果距离上一次的请求的时间大于RATE的时间，计算这段时间间隔中生成的令牌，如果>2,桶容量加上（计算的令牌-1） 如果==1，就不做操作（因为这一次操作要消耗一个令牌）
保持桶内令牌容量<=10
刷新时间戳为本次请求

若小于RATE时间，返回false

## RateLimitProvider
维护了一个`rateLimitMap`，用于存储每个接口的速率限制器实例
`getLimitMap()`根据接口名称返回相应的接口速率限制器类型

# V4.1 调用端熔断保护
![输入图片说明](/imgs/2025-03-24/OVyhLb4c2s2lgCup.png)
A调用B，B调用C，若此时C故障，B无法取得C的响应而一直在等待，此时A还在一直频繁调用B，会导致B宕机

在一个服务作为调用端调用另外一个服务时，为了防止被调用的服务出现问题而影响到作为调用端的这个服务，这个服务也需要进行自我保护。而最有效的自我保护方式就是熔断。

熔断器一般要实现三个状态：闭合、断开和半开，分别对应于正常、故障和故障后检测故障是否已被修复的场景。

-   **闭合**：正常情况，后台会对调用失败次数进行积累，到达一定阈值或比例时则自动启动熔断机制。
    

-   **断开**：一旦对服务的调用失败次数达到一定阈值时，熔断器就会打开，这时候对服务的调用将直接返回一个预定的错误，而不执行真正的网络调用。同时，熔断器需要设置一个固定的时间间隔，当处理请求达到这个时间间隔时会进入半熔断状态。
    

-   **半开**：在半开状态下，熔断器会对通过它的部分请求进行处理，如果对这些请求的成功处理数量达到一定比例则认为服务已恢复正常，就会关闭熔断器，反之就会打开熔断器。
    

熔断设计的一般思路是，在请求失败 N 次后在 X 时间内不再请求，进行熔断；然后再在 X 时间后恢复 M% 的请求，如果 M% 的请求都成功则恢复正常，关闭熔断，否则再熔断 Y 时间，依此循环。

在熔断的设计中，根据 Netflix 的开源组件 hystrix 的设计，我们可以仿照以下二个模块：熔断请求判断算法、熔断恢复机制

-   熔断请求判断机制算法：根据事先设置的在固定时间内失败的比例来计算。
    

-   熔断恢复：对于被熔断的请求，每隔 X 时间允许部分请求通过，若请求都成功则恢复正常。

## **建立CircuitBreaker类实现熔断器逻辑**

在这个实现中，熔断器类 `CircuitBreaker` 管理熔断器的状态，并根据请求的成功和失败情况进行状态转换。具体步骤如下：

-   1.
    
    **失败 N 次后熔断**：当失败次数达到阈值时，熔断器进入打开状态，拒绝请求。
    

-   2.
    
    **打开状态持续 X 时间**：在打开状态持续 X 时间后，熔断器进入半开状态，允许部分请求通过。
    

-   3.
    
    **恢复 M% 的请求**：在半开状态下，熔断器允许请求通过，并根据请求的成功率决定是否恢复到闭合状态或重新进入打开状态。
    

-   4.
    
    **如果 M% 的请求都成功**：恢复到闭合状态，正常处理请求。
    

-   5.
    
    **否则再熔断 Y 时间**：如果请求失败，则进入打开状态，等待 Y 时间，然后再次尝试进入半开状态。


**在调用端最顶层的ClientProxy上添加熔断逻辑**，在动态代理调用前进行检测，如果异常立即返回

### allowRequest()
若熔断器处于`OPEN`状态，检查自上次失败以来是否已经过了指定的重置时间，如果过了，会进入`HALF_OPEN`状态并允许请求
若处于`HALF_OPEN`状态，yun
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ0OTgxMjAwMiwtMTUxNDYzMDQ5MiwtMT
Y2MzIxMzYwMiw4OTIxMTM0MDVdfQ==
-->