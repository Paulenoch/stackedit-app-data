RPC是解决分布式系统通信问题的框架，分布式系统的一大特点是高并发，为保证服务在高访问量、高并发的场景下，依旧稳定和高可用，需要从服务端和调用端进行保护

# V4.1 服务限流
当调用端发送请求过来时，服务端在执行业务逻辑之前先执行限流逻辑，如果发现访问量过大并且超出了限流的阈值，就让服务端直接抛回给调用端一个限流异常，否则就执行正常的业务逻辑。

常见限流算法：
- 固定窗口计数法：将时间划分为固定大小的窗口，规定每个窗口内的请求上限；优点：简单易实现；缺点：限流不够平滑，无法保证限流速率

- 滑动窗口计数法：例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 `60(请求数)/60（窗口数）` 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。优点：可以应对激增的流量，颗粒度更小限流控制更精准；缺点：基本同上

- 漏桶算法：把发请求的动作比作成注水到桶中，处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。优点：简单可控制限流速率；缺点：无法应对流量激增，若发请求的速率一直高于处理请求的速率，桶一直是满的会导致部分新的请求被丢弃

- 令牌桶算法：桶里装的是令牌，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。优点：可以限制平均速率和应对突然激增的流量。可以动态调整生成令牌的速率。

假设令牌桶最大容量为n，每秒产生r个令牌

平均速率：则随着时间推延，处理请求的平均速率越来越趋近于每秒处理r个请求，说明令牌桶算法可以控制平均速率

瞬时速率：如果在一瞬间有很多请求进来，此时来不及产生令牌，则在一瞬间最多只有n个请求能获取到令牌执行业务逻辑，所以令牌桶算法也可以控制瞬时速率





<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE2NjcwOTg0OSw4OTIxMTM0MDVdfQ==
-->