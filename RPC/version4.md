RPC是解决分布式系统通信问题的框架，分布式系统的一大特点是高并发，为保证服务在高访问量、高并发的场景下，依旧稳定和高可用，需要从服务端和调用端进行保护

# V4.0 服务端限流
当调用端发送请求过来时，服务端在执行业务逻辑之前先执行限流逻辑，如果发现访问量过大并且超出了限流的阈值，就让服务端直接抛回给调用端一个限流异常，否则就执行正常的业务逻辑。

常见限流算法：
- 固定窗口计数法：将时间划分为固定大小的窗口，规定每个窗口内的请求上限；优点：简单易实现；缺点：限流不够平滑，无法保证限流速率

- 滑动窗口计数法：例如我们的接口限流每分钟处理 60 个请求，我们可以把 1 分钟分为 60 个窗口。每隔 1 秒移动一次，每个窗口一秒只能处理不大于 `60(请求数)/60（窗口数）` 的请求， 如果当前窗口的请求计数总和超过了限制的数量的话就不再处理其他请求。当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。优点：可以应对激增的流量，颗粒度更小限流控制更精准；缺点：基本同上

- 漏桶算法：把发请求的动作比作成注水到桶中，处理请求的过程可以比喻为漏桶漏水。我们往桶中以任意速率流入水，以一定速率流出水。当水超过桶流量则丢弃，因为桶容量是不变的，保证了整体的速率。如果想要实现这个算法的话也很简单，准备一个队列用来保存请求，然后我们定期从队列中拿请求来执行就好了（和消息队列削峰/限流的思想是一样的）。优点：简单可控制限流速率；缺点：无法应对流量激增，若发请求的速率一直高于处理请求的速率，桶一直是满的会导致部分新的请求被丢弃

- 令牌桶算法：桶里装的是令牌，请求在被处理之前需要拿到一个令牌，请求处理完毕之后将这个令牌丢弃（删除）。我们根据限流大小，按照一定的速率往桶里添加令牌。如果桶装满了，就不能继续往里面继续添加令牌了。优点：可以限制平均速率和应对突然激增的流量。可以动态调整生成令牌的速率。

假设令牌桶最大容量为n，每秒产生r个令牌

平均速率：则随着时间推延，处理请求的平均速率越来越趋近于每秒处理r个请求，说明令牌桶算法可以控制平均速率

瞬时速率：如果在一瞬间有很多请求进来，此时来不及产生令牌，则在一瞬间最多只有n个请求能获取到令牌执行业务逻辑，所以令牌桶算法也可以控制瞬时速率

## 令牌桶算法实现
令牌产生速度`RATE`
桶容量`CAPACITY`
当前桶容量`curCapacity`
时间戳`timeStamp`

`timeStamp`为上一次请求获取令牌的时间，我们没必要真的实现计时器每秒产生多少令牌放入容器中，只要记住上一次请求到来的时间，和这次请求的差值就知道在这段时间内产生了多少令牌

若`curCapacity>0`，直接返回true

若桶无剩余，如果距离上一次的请求的时间大于RATE的时间，计算这段时间间隔中生成的令牌，如果>2,桶容量加上（计算的令牌-1） 如果==1，就不做操作（因为这一次操作要消耗一个令牌）
保持桶内令牌容量<=10
刷新时间戳为本次请求

若小于RATE时间，返回false

## RateLimitProvider
维护了一个`rateLimitMap`，用于存储每个接口的速率限制器实例
`getLimitMap()`根据接口名称返回相应的接口速率限制器类型

# V4.1 调用端熔断保护
![输入图片说明](/imgs/2025-03-24/OVyhLb4c2s2lgCup.png)
A调用B，B调用C，若此时C故障，B无法取得C的响应而一直在等待，此时A还在一直频繁调用B，会导致B宕机

在一个服务作为调用端调用另外一个服务时，为了防止被调用的服务出现问题而影响到作为调用端的这个服务，这个服务也需要进行自我保护。而最有效的自我保护方式就是熔断。



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2NjMyMTM2MDIsODkyMTEzNDA1XX0=
-->