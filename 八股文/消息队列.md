# 消息队列的应用场景
- 异步处理，用户下单后即可返回结果，等数据库处理完成后再正式通知用户下单完成
- 削峰/限流：大量请求涌入的时候，先全部存放于消息队列中，避免直接把后端服务打垮掉
- 降低系统耦合度![输入图片说明](/imgs/2025-05-29/3wgp7kkU3X501wEY.png)
- 处理分布式事务：**服务A执行本地事务**，如扣款，并**发送一条“扣款成功”的消息到消息队列**（这个操作要保证与本地事务的原子性，比如本地消息表/事务消息等技术）。**服务B监听到消息后执行自己的本地事务**，如发货。如果**服务B处理失败，可以重试，或者通知服务A进行人工处理**。
- 保证数据按照特定的顺序被处理
- 延时/定时处理

# 引入消息队列可能会带来哪些问题
-   **系统可用性降低：** 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！
-   **系统复杂性提高：** 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！
-   **一致性问题：** 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!

# Kafka
Kafka 是一个分布式流式处理平台。

流平台具有三个关键功能：

1.  **消息队列**：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。
2.  **容错的持久方式存储记录消息流**：Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。
3.  **流式处理平台：** 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。

### 相比其他MQ的优势
-   **极致的性能**：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。
-   **生态系统兼容性无可匹敌**：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。

![输入图片说明](/imgs/2025-05-29/lbYVreMPacTGGZFU.png)
Kafka 将生产者发布的消息发送到 **Topic（主题）** 中，需要这些消息的消费者可以订阅这些 **Topic（主题）**
- **Broker（代理）** : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluste
-   **Topic（主题）** : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。
-   **Partition（分区）** : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。

> 划重点：**Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。

### Kafka的


<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ5ODQ3MzYwNCwyMDkyMTI1NDM2LC05Nj
UxNzE0MzIsMTEyNzEyMDU3OCwtMjA4ODc0NjYxMl19
-->