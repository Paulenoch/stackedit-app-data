# 什么是操作系统
-   操作系统本质上是一个运行在计算机上的软件程序 ，主要用于管理计算机硬件和软件资源。 举例：运行在你电脑上的所有应用程序都通过操作系统来调用系统内存以及磁盘等等硬件。
-   操作系统存在屏蔽了硬件层的复杂性。 操作系统就像是硬件使用的负责人，统筹着各种相关事项。
-   操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。

# 用户态和内核态
- 用户态的进程可以直接读取用户程序的数据，权限较低。当需要执行需要权限的特殊操作时（读写磁盘，网络通信），就需要向操作系统发起系统调用请求，进入内核态。
- 内核态运行的进程几乎可以访问计算机的任何资源包括系统的内存空间、设备、驱动程序等，不受限制，拥有非常高的权限。当操作系统接收到进程的系统调用请求时，就会从用户态切换到内核态，执行相应的系统调用，并将结果返回给进程，最后再从内核态切换回用户态。

进入内核态需要付出较高的开销（需要进行一系列的上下文切换和权限检查），应该尽量减少进入内核态的次数，以提高系统的性能和稳定性。

### 为什么要区分用户态和内核态
对于一些危险的指令如内存分配，设置时钟等，若所有程序都可以无条件操作的话对系统的稳定性会有极大影响
如果只有内核态，所有的程序和进程都需要共享系统资源导致竞争和冲突

### 用户态切换到内核态的三种方式
-   **系统调用（Trap）**：用户态进程 **主动** 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。
-   **中断（Interrupt）**：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
-   **异常（Exception）**：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

### 系统调用的过程
1. 用户态的程序发起系统调用，由于涉及特权指令，用户态权限不足，因此会中断执行，也就是Trap（Trap是一种中断）
2. 发生中断后，当前CPU执行的程序会中断，跳转到中断处理程序，内核程序开始执行，开始系统调用
3. 当系统调用处理完成后，操作系统使用特权指令（如 `iret`、`sysret` 或 `eret`）切换回用户态，恢复用户态的上下文，继续执行用户程序。

# 进程与线程
多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)**资源，但是每个线程有自己的**程序计数器**、**虚拟机栈** 和 **本地方法栈**。

-   线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。
-   线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。
-   线程执行开销小，但不利于资源的管理和保护；而进程正相反。

### 有了进程为什么还需要线程
-   进程切换是一个开销很大的操作，线程切换的成本较低。
-   线程更轻量，一个进程可以创建多个线程。
-   多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。而进程只能在一个时间干一件事，如果在执行过程中遇到阻塞问题比如 IO 阻塞就会挂起直到结果返回。
-   同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。

# 线程间的同步方式有哪些
目的：避免关键资源使用冲突
1.  **互斥锁(Mutex)** ：只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如 Java 中的 `synchronized` 关键词和各种 `Lock` 都是这种机制。
2.  **读写锁（Read-Write Lock）** ：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。
3.  **信号量(Semaphore)** ：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
4.  **屏障（Barrier）** ：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。当一个线程到达屏障时，它会停止执行并等待其他线程到达屏障，直到所有线程都到达屏障后，它们才会一起继续执行。比如 Java 中的 `CyclicBarrier` 是这种机制。
5.  **事件(Event)** :Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

# 进程间的
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE0NDM0NzQwNSwtNTg0NjAxMDI4LC0yNj
gzMDcyMiwtMTAzNjgyMDk3OSwxMTc0MjM5NSwtNTIyNDE1OTE5
LC03OTQ4MjM4OTQsLTE1MDEwNjUwMzksLTIwODg3NDY2MTJdfQ
==
-->