# 1. Redis常用的数据结构
- String：简单动态字符串
- List：双向链表
- Set：HashSet
- Hash：HashMap
- ZSet：类似Set，加了一个权重参数score，使元素能按照score排序，数据量较大时同时使用skiplist和hashtable实现

# ZSet中的跳表
当 ZSet 中的元素数量较多，或者元素成员（member）是比较长的字符串时，Redis 就会采用跳表作为其底层实现之一。为了弥补跳表在按成员查找分数（`ZSCORE` 命令）上的低效，Redis 实际上是**同时使用了跳表和哈希表**来共同实现 ZSet。

-   **跳表（Skiplist）**：用于按分数（score）进行高效的范围查找和排序。
    
-   **哈希表（Hashtable）**：用于以 O(1) 的时间复杂度根据成员（member）查找其对应的分数。
    

两者通过指针互相关联，保证了数据的一致性。

### 什么是跳表？

跳表是一种**概率性数据结构**，可以看作是对有序链表的优化。它通过在原始链表的基础上增加多级“快速通道”（索引层），来实现类似二分查找的高效查找性能。

想象一下一个普通的有序链表，要查找一个元素，你必须从头到尾逐个遍历，时间复杂度是 O(N)。

_（这是一个普通的有序链表）_

现在，我们从这个链表中每隔一个元素，就提取出来，并增加一个指向上层节点的指针，这就构成了一个新的“索引”层。

_（这是一个包含多级索引的跳表）_

**查找过程**：

1.  从最高层的索引开始查找。
    
2.  在当前层，向右移动，直到找到一个大于或等于目标值的节点，或者到达当前层的末尾。
    
3.  如果找到了大于目标值的节点，就从前一个节点**下降一层**，重复步骤 2。
    
4.  最终，在最底层（原始链表层）找到目标元素或确定其不存在。
    

通过这种方式，跳表可以跳过大量节点，其平均查找、插入和删除的时间复杂度都是 **O(logN)**，与平衡树（如红黑树）相当，但实现起来却简单得多。

----------

### Redis 中的跳表实现

Redis 的跳表设计非常精巧，我们来看一下它的具体结构。

#### 1. 跳表节点 (zskiplistNode)

每个跳表节点都包含以下关键部分：

-   **`ele` (element)**: 存储的成员（member）值。
    
-   **`score` (分数)**: 该成员对应的分数，用于排序。
    
-   **`backward` (后退指针)**: 指向其在原始链表中的前一个节点。这使得跳表可以从后向前遍历。
    
-   **`level[]` (层级数组)**: 这是跳表的核心。每个节点都包含一个层级数组，数组的每个元素 (`zskiplistLevel`) 都包含：
    
    -   **`forward` (前进指针)**: 指向同一层级的下一个节点。
        
    -   **`span` (跨度)**: 记录当前节点的前进指针指向下一个节点之间，跨越了多少个节点。这个“跨度”是计算排名（`ZRANK` 命令）的关键。
        

#### 2. 跳表结构 (zskiplist)

整个跳表由一个 `zskiplist` 结构来管理，它包含：

-   **`header` (头节点)**: 一个不存储任何实际数据的头节点，其层级数组包含指向各层级第一个节点的指针。
    
-   **`tail` (尾节点)**: 指向跳表的最后一个节点，方便在表尾进行操作。
    
-   **`length` (长度)**: 记录跳表中节点的总数量（不包括头节点）。
    
-   **`level` (层级)**: 记录当前跳表的最大层级数。
    

下图是 Redis 跳表一个节点的简化示意图：

```
+----------------+
| ele (member)   |
| score          |
+----------------+
| *backward      |
+----------------+
| level[0]       | --> forward, span
+----------------+
| level[1]       | --> forward, span
+----------------+
| ...            |
+----------------+
| level[n]       | --> forward, span
+----------------+
```

#### 3. 随机的层级

跳表的一个有趣之处在于，新节点被插入时，它的层级数是**随机**决定的。Redis 的策略是：

-   每个节点至少有 1 层（即原始链表层）。
    
-   之后，以 25% 的概率增加一层，直到达到最大层级限制（Redis 中是 32 层）或者随机过程停止。
    

这种随机性使得跳表的结构在动态增删下，能够大概率保持平衡，从而保证 O(logN) 的性能。

#### 4. `span` (跨度) 的作用

`span` 是 Redis 跳表实现中的一个亮点。它记录了从当前节点的某一层级，到该层级下一个节点之间，有多少个底层节点。

在上图中，从头节点（header）的 L2 层到节点 7，`span` 是 2，因为中间跨越了 2 个节点（节点 1 和节点 3）。

**有了 `span`，计算一个成员的排名就变得非常高效**：

1.  在查找该成员的路径上，将经过的所有前进指针的 `span` 值累加起来。
    
2.  最终得到的总和，就是该成员在有序集合中的排名。
    

这使得 `ZRANK` (获取排名) 命令的时间复杂度也保持在 O(logN)。

# 2. Redis单线程模型了解吗
对于读写命令，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）

# 3. 单线程如何监听大量的客户端连接
通过IO多路复用，I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗

# 4. Redis为何给缓存数据设定过期时间，如何判断是否过期，过期数据删除策略？
1. 缓存大小有限，短信验证码之类的功能也要设定过期时间
2. 通过一个过期字典（hash表）保存过期时间
3. redis采用定期删除（周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期）+ 惰性删除（只会在取出/查询 key 的时候才对数据进行过期检查）

# 5. Redis内存淘汰策略
六种
volatile/allkeys * lru/ttl/random

后续加入lfu

# 6. RDB持久化
Redis通过创建snapshot来获得存储在内存里面的数据在某个时间点上的副本

# 7. AOF持久化
每执行一条更改Redis中的数据的命令，Redis将该命令写入到内存缓存`server.aof_buf`中，再更具`appendfsync`配置决定什么时候同步到硬盘中的AOF文件

# 8. 如何使用Redis事务
通过MULTI, EXEC, DISCARD, WATCH等关键字

# 9. Redis事务支持原子性嘛
不支持，事务运行错误的情况下，只有错误的指令不会被执行，且Redis不支持回滚

# 10. 如何解决Redis事务的缺陷
Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。

一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。

不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此，**严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。**


# 11. 什么是Big Key/Hot Key/
一个key对应的value占用的内存比较大/一个 key 的访问次数比较多且明显多于其他 key
处理方案
- 分割bigkey，手动清理，采用合适的数据结构，开启lazy-free
- 读写分离，使用Redis Cluster，二级缓存

# 12. 如何避免大量key集中过期
给key设置随机过期时间+开启lazy-free

# 13. Redis内存碎片
产生原因：
**Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。**
**频繁修改 Redis 中的数据也会产生内存碎片。**

# 14. 缓存穿透
大量请求的key不在缓存中，也不再数据库中	
解决：
- 缓存无效key：查到某个key不在数据库中，将其存入缓存
- 布隆过滤器

# 利用布隆过滤器防止缓存穿透，如果此时我更新了数据库，更新后数据如何同步到布隆过滤器中
标准布隆过滤器（Standard Bloom Filter）的一个关键特性：**它不支持删除或更新操作**。
布隆过滤器的核心是一个位数组（bit array）和多个哈希函数。添加一个元素时，会用多个哈希函数计算出几个位置，并将位数组中这些位置的 bit 设置为 1。

当你尝试删除一个元素时，你可能会想把这些位置的 bit 重新设置为 0。但问题在于，**这些 bit 位可能被其他元素共享**。如果你强行设置为 0，就会导致其他本应存在的元素被“误删”，从而产生**错误否定（False Negative）**，这是布隆过滤器绝对不能容忍的（它可以容忍错误肯定，但不能容忍错误否定）。

方案一：定期重建 (最常用、最简单)
方案二：使用支持删除的布隆过滤器变种 (Counting Bloom Filter)

# 15. 缓存击穿
请求的 key 对应的是 **热点数据**，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**。这就可能会导致瞬时大量的请求直接打到了数据库上

解决：
- 提前预热
- 加锁，设置互斥锁保证只有一个请求能查询数据库并更新缓存
- 热点Key永不过期
- 逻辑过期，缓存里不仅存数据，还存一个**过期时间戳**，查询时如果逻辑上未过期，直接返回；如果逻辑上过期，后台异步更新，但仍返回旧数据。

# 16. 缓存雪崩
**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力**

解决：
- Redis集群


# 17. 保证Redis服务高可用
Redis Sentinel集群
### 什么是Sentinel，作用？
哨兵是Redis的一种运行模式，监控所有redis节点，故障转移，通知，配置提供

### Sentinel如何检测节点是否下线
主观下线：单个sentinel认为下线；客观下线：过半sentinel认为下线
每个sentinel节点以固定频率向整个集群中的master和slave发送ping，如果发现master下线，开启故障转移

### 如何选举出新的master
slave优先级
复制进度：选出数据最完整的的slave
runid：前两项一样，选runid最小的

# 18. Redis Cluster
解决缓存的数据量太大和并发量太大的问题

通过部署多台Redis主节点，同时提供读写服务，缓存的数据库相对均匀地分布在这些主节点上，客户端的请求通过路由规则转发到目标master上

为保证高可用，每台master配备一多个slave

### Redis Cluster是如何分片的
采用哈希槽分区，每一个键值对都属于一个哈希槽

### 节点之间如何通信
Gossip协议
![输入图片说明](/imgs/2025-03-25/hy5BibOnmpqkvNzi.png)
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEwMjExMTg0MjEsLTIwOTIwNDc2MTQsLT
QzODY4OTQ4NCwyODk3ODU0MjgsLTk1NDY1NjQ5MywtMjA4ODc0
NjYxMl19
-->