# 1. Redis常用的数据结构
- String：简单动态字符串
- List：双向列表
- Set：HashSet
- Hash：HashMap
- ZSet：类似Set，加了一个权重参数score，使元素能按照score排序

# 2. Redis单线程模型了解吗
对于读写命令，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作，Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）

# 3. 单线程如何监听大量的客户端连接
通过IO多路复用，I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗

# 4. Redis为何给缓存数据设定过期时间，如何判断是否过期，过期数据删除策略？
1. 缓存大小有限，短信验证码之类的功能也要设定过期时间
2. 通过一个过期字典（hash表）保存过期时间
3. redis采用定期删除（周期性地随机从设置了过期时间的 key 中抽查一批，然后逐个检查这些 key 是否过期）+ 惰性删除（只会在取出/查询 key 的时候才对数据进行过期检查）

# 5. Redis内存淘汰策略
六种
volatile/allkeys * lru/ttl/random

后续加入lfu

# 6. RDB持久化
Redis通过创建snapshot来获得存储在内存里面的数据在某个时间点上的副本

# 7. AOF持久化
每执行一条更改Redis中的数据的命令，Redis将该命令写入到内存缓存`server.aof_buf`中，再更具`appendfsync`配置决定什么时候同步到硬盘中的AOF文件

# 8. 如何使用Redis事务
通过MULTI, EXEC, DISCARD, WATCH等关键字

# 9. Redis事务支持原子性嘛
不支持，事务运行错误的情况下，只有错误的指令不会被执行，且Redis不支持回滚

# 10. 如何解决Redis事务的缺陷
Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。

一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。

不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此，**严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。**

如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。
另外，Redis 7.0 新增了 [Redis functions](https://redis.io/docs/manual/programmability/functions-intro/) 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。

# 11. 什么是Big Key/Hot Key/
一个key对应的value占用的内存比较大/一个 key 的访问次数比较多且明显多于其他 key
处理方案
- 分割bigkey，手动清理，采用合适的数据结构，开启lazy-free
- 读写分离，使用Redis Cluster，二级缓存

# 12. 如何避免大量key集中过期
给key设置随机过期时间+开启lazy-free

# 13. Redis内存碎片
产生原因：
**Redis 存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。**
**频繁修改 Redis 中的数据也会产生内存碎片。**

# 14. 缓存穿透
大量请求的key不在缓存中，也不再数据库中	
解决：
- 缓存无效key：查到某个key不在数据库中，将其存入缓存
- 布隆过滤器

# 15. 缓存击穿
请求的 key 对应的是 **热点数据**，该数据 **存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）**。这就可能会导致瞬时大量的请求直接打到了数据库上

解决：
- 提前预热
- 加锁，设置互斥锁保证只有一个请求能查询数据库并更新缓存

# 16. 缓存雪崩
**缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力**

解决：
- Redis集群


# 保证Redis服务高可用
Redis Sentinel集群
### 什么是Sentinel，作用？
哨兵是Redis的一种运行模式，监控所有redis节点，故障转移，通知，配置提供

### Sentinel如何检测节点是否下线
主观下线：单个sentinel认为下线；客观下线：过半sentinel认为下线
每个sentinel节点以固定频率向整个集群中的master和slave发送ping，如果发现master下线，开启故障转移

### 如何选举中新的
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI0ODkwMDg4MiwtMjA4ODc0NjYxMl19
-->