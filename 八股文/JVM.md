# 1. 运行时数据区
![输入图片说明](/imgs/2025-03-25/sOyOJsJGPSPUHAkO.png)

# 2. 对象的创建
Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

step2：分配内存

step3：初始化零值

step4：设置对象头

step5：执行init方法

# 3. 对象的访问定位
句柄：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

直接指针：reference 中存储的直接就是对象的地址。

# 4. 堆空间的基本结构，什么情况下对象进入老年代
![输入图片说明](/imgs/2025-03-25/JgLtsq5dub1TnuwM.png)

大部分情况，对象首先在Eden区域分布
长期存活的对象进入老年代
大对象直接进入老年代

# 5. 如何判断对象是否死亡
引用计数法：给对象中添加一个引用计数器，每有一个地方引用它计数加一
无法解决对象之间循环引用的问题

可达性分析算法：通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
**哪些对象可以作为 GC Roots 呢？**

-   虚拟机栈(栈帧中的局部变量表)中引用的对象
-   本地方法栈(Native 方法)中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   所有被同步锁持有的对象
-   JNI（Java Native Interface）引用的对象

# 6. 对象可以被回收，就代表一定会被回收吗？
可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTIzNzAxNDMzN119
-->