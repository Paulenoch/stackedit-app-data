# 1. 运行时数据区
![输入图片说明](/imgs/2025-03-25/sOyOJsJGPSPUHAkO.png)
### 1. **程序计数器（Program Counter Register）**

-   **作用**：线程私有，用于存储当前线程所执行的字节码的行号指示器。
    
-   **特点**：
    
    -   每个线程一个独立的程序计数器。
        
    -   如果线程正在执行的是一个 native 方法，则计数器值为空（Undefined）。
        
    -   这是唯一一个不会出现 OutOfMemoryError 的区域。

### 2. **Java 虚拟机栈（Java Virtual Machine Stack）**

-   **作用**：线程私有，生命周期与线程一致。用于存储方法的局部变量表、操作数栈、动态链接、方法返回地址等。
    
-   **特点**：
    
    -   每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量等信息。
        
    -   如果线程请求的栈深度超过了虚拟机栈的最大深度，会抛出 `StackOverflowError`。
        
    -   如果内存无法申请足够空间时，会抛出 `OutOfMemoryError`。
### 3. **本地方法栈（Native Method Stack）**

-   **作用**：与 Java 虚拟机栈类似，但用于为虚拟机使用到的 native 方法服务。
    
-   **特点**：
    
    -   HotSpot JVM 通常直接将本地方法栈与 Java 虚拟机栈合并。
        
    -   同样可能抛出 `StackOverflowError` 或 `OutOfMemoryError`。
### 4. **Java 堆（Heap）**

-   **作用**：JVM 所管理的内存中最大的一块，所有对象实例和数组都在这里分配。
    
-   **特点**：
    
    -   所有线程共享。
        
    -   是垃圾回收器（GC）管理的主要区域，因此也叫“GC 堆”。
        
    -   按照 GC 策略，堆通常会进一步划分为：**新生代（Young Generation）** 和 **老年代（Old Generation）**。
        
    -   新生代还可以再细分为 Eden 区、Survivor0、Survivor1。
        
    -   如果堆中没有内存可用且无法扩展，则抛出 `OutOfMemoryError`。

### 5. **方法区（Method Area）**

-   **作用**：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
    
-   **特点**：
    
    -   所有线程共享。
        
    -   在 JDK 8 之前由永久代（PermGen）实现；JDK 8 开始被移除，改为元空间（Metaspace）。
        
    -   方法区也可能发生 `OutOfMemoryError`。
### 6. **运行时常量池（Runtime Constant Pool）**

-   **作用**：方法区的一部分，用于存放编译期生成的各种字面量和符号引用。
    
-   **特点**：
    
    -   也支持动态生成常量，如调用 `String.intern()`。
        
    -   如果常量池过大导致内存不足，会抛出 `OutOfMemoryError`。

# 2. 对象的创建
Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

step2：分配内存

step3：初始化零值

step4：设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中**

step5：执行init方法

# 3. 对象的访问定位
句柄：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

直接指针：reference 中存储的直接就是对象的地址。

# 4. 堆空间的基本结构，什么情况下对象进入老年代
![输入图片说明](/imgs/2025-03-25/JgLtsq5dub1TnuwM.png)

大部分情况，对象首先在Eden区域分布
长期存活的对象进入老年代
大对象直接进入老年代

# 5. 如何判断对象是否死亡
引用计数法：给对象中添加一个引用计数器，每有一个地方引用它计数加一
无法解决对象之间循环引用的问题

可达性分析算法：通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
**哪些对象可以作为 GC Roots 呢？**

-   虚拟机栈(栈帧中的局部变量表)中引用的对象
-   本地方法栈(Native 方法)中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   所有被同步锁持有的对象
-   JNI（Java Native Interface）引用的对象

# 6. 对象可以被回收，就代表一定会被回收吗？
可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。


# 垃圾回收算法
 - 标记-清除：标记和清除的效率不高，会产生不连续的内存碎片
![输入图片说明](/imgs/2025-09-18/CCl2CfuwiEfOGH3G.png)

- 复制：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**可用内存变小**如果存活对象数量比较大，复制性能会变得很差。
![输入图片说明](/imgs/2025-09-18/BStYupEU4xC1GkM1.png)

- 标记-整理：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

# 7. 垃圾收集器，各自的特点
- Serial：单线程收集器，工作室必须暂停其他所有工作线程
- ParNew：Serial的多线程版本
- Paallel Scavenge：关注点是吞吐量（高效率的利用 CPU）
- CMS：**标记-清除”算法**
- **初始标记：** 短暂停顿，标记直接与 root 相连的对象（根对象）；
-   **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
-   **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
-   **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

- G1：**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。


# 类加载的过程
加载——连接——初始化
-   类加载器是一个负责加载类的对象，用于实现类加载过程中的加载这一步。
-   每个 Java 类都有一个引用指向加载它的 `ClassLoader`。
-   数组类不是通过 `ClassLoader` 创建的（数组类没有对应的二进制字节流），是由 JVM 直接生成的。

类加载器的主要作用就是动态加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

JVM 中内置了三个重要的 `ClassLoader`：

1.  **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2.  **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3.  **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

# 双亲委派模型
-   `ClassLoader` 类使用委托模型来搜索类和资源。
-   双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
-   `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

目的：避免类的重复加载和防止核心 API 被篡改

### 打破双亲委派模型方法
Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制。


<!--stackedit_data:
eyJoaXN0b3J5IjpbMjEzMzkwNDk0MywtNTQ3MDY2MzEsLTc2Mj
YwMjQ1LDEwMzY5MjY1ODgsLTEyNTI5MDc3NzcsODAyNDQ2NDYz
XX0=
-->