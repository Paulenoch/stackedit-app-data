# 1. 运行时数据区
![输入图片说明](/imgs/2025-03-25/sOyOJsJGPSPUHAkO.png)
### 1. **程序计数器（Program Counter Register）**

-   **作用**：线程私有，用于存储当前线程所执行的字节码的行号指示器。
    
-   **特点**：
    
    -   每个线程一个独立的程序计数器。
        
    -   如果线程正在执行的是一个 native 方法，则计数器值为空（Undefined）。
        
    -   这是唯一一个不会出现 OutOfMemoryError 的区域。

### 2. **Java 虚拟机栈（Java Virtual Machine Stack）**

-   **作用**：线程私有，生命周期与线程一致。用于存储方法的局部变量表、操作数栈、动态链接、方法返回地址等。
    
-   **特点**：
    
    -   每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量等信息。
        
    -   如果线程请求的栈深度超过了虚拟机栈的最大深度，会抛出 `StackOverflowError`。
        
    -   如果内存无法申请足够空间时，会抛出 `OutOfMemoryError`。
### 3. **本地方法栈（Native Method Stack）**

-   **作用**：与 Java 虚拟机栈类似，但用于为虚拟机使用到的 native 方法服务。
    
-   **特点**：
    
    -   HotSpot JVM 通常直接将本地方法栈与 Java 虚拟机栈合并。
        
    -   同样可能抛出 `StackOverflowError` 或 `OutOfMemoryError`。


# 2. 对象的创建
Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

step2：分配内存

step3：初始化零值

step4：设置对象头

step5：执行init方法

# 3. 对象的访问定位
句柄：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

直接指针：reference 中存储的直接就是对象的地址。

# 4. 堆空间的基本结构，什么情况下对象进入老年代
![输入图片说明](/imgs/2025-03-25/JgLtsq5dub1TnuwM.png)

大部分情况，对象首先在Eden区域分布
长期存活的对象进入老年代
大对象直接进入老年代

# 5. 如何判断对象是否死亡
引用计数法：给对象中添加一个引用计数器，每有一个地方引用它计数加一
无法解决对象之间循环引用的问题

可达性分析算法：通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
**哪些对象可以作为 GC Roots 呢？**

-   虚拟机栈(栈帧中的局部变量表)中引用的对象
-   本地方法栈(Native 方法)中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   所有被同步锁持有的对象
-   JNI（Java Native Interface）引用的对象

# 6. 对象可以被回收，就代表一定会被回收吗？
可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

# 7. 垃圾收集算法，各自的特点
- Serial：单线程收集器，工作室必须暂停其他所有工作线程
- ParNew：Serial的多线程版本
- Paallel Scavenge：关注点是吞吐量（高效率的利用 CPU）
- CMS：**标记-清除”算法**
- **初始标记：** 短暂停顿，标记直接与 root 相连的对象（根对象）；
-   **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
-   **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
-   **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

- G1：**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)** 。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 G1 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1NzE2NjYzNjQsODAyNDQ2NDYzXX0=
-->