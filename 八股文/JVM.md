# 1. 运行时数据区
![输入图片说明](/imgs/2025-03-25/sOyOJsJGPSPUHAkO.png)
### 1. **程序计数器（Program Counter Register）**

-   **作用**：线程私有，用于存储当前线程所执行的字节码的行号指示器。
    
-   **特点**：
    
    -   每个线程一个独立的程序计数器。
        
    -   如果线程正在执行的是一个 native 方法，则计数器值为空（Undefined）。
        
    -   这是唯一一个不会出现 OutOfMemoryError 的区域。

### 2. **Java 虚拟机栈（Java Virtual Machine Stack）**

-   **作用**：线程私有，生命周期与线程一致。用于存储方法的局部变量表、操作数栈、动态链接、方法返回地址等。
    
-   **特点**：
    
    -   每个方法执行时都会创建一个栈帧（Stack Frame），用于存储局部变量等信息。
        
    -   如果线程请求的栈深度超过了虚拟机栈的最大深度，会抛出 `StackOverflowError`。
        
    -   如果内存无法申请足够空间时，会抛出 `OutOfMemoryError`。
### 3. **本地方法栈（Native Method Stack）**

-   **作用**：与 Java 虚拟机栈类似，但用于为虚拟机使用到的 native 方法服务。
    
-   **特点**：
    
    -   HotSpot JVM 通常直接将本地方法栈与 Java 虚拟机栈合并。
        
    -   同样可能抛出 `StackOverflowError` 或 `OutOfMemoryError`。
### 4. **Java 堆（Heap）**

-   **作用**：JVM 所管理的内存中最大的一块，所有对象实例和数组都在这里分配。
    
-   **特点**：
    
    -   所有线程共享。
        
    -   是垃圾回收器（GC）管理的主要区域，因此也叫“GC 堆”。
        
    -   按照 GC 策略，堆通常会进一步划分为：**新生代（Young Generation）** 和 **老年代（Old Generation）**。
        
    -   新生代还可以再细分为 Eden 区、Survivor0、Survivor1。
        
    -   如果堆中没有内存可用且无法扩展，则抛出 `OutOfMemoryError`。

### 5. **方法区（Method Area）**

-   **作用**：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。
    
-   **特点**：
    
    -   所有线程共享。
        
    -   在 JDK 8 之前由永久代（PermGen）实现；JDK 8 开始被移除，改为元空间（Metaspace）。
        
    -   方法区也可能发生 `OutOfMemoryError`。
### 6. **运行时常量池（Runtime Constant Pool）**

-   **作用**：方法区的一部分，用于存放编译期生成的各种字面量和符号引用。
    
-   **特点**：
    
    -   也支持动态生成常量，如调用 `String.intern()`。
        
    -   如果常量池过大导致内存不足，会抛出 `OutOfMemoryError`。

# 2. 对象的创建
Step1:类加载检查

虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程

step2：分配内存

step3：将分配到的内存初始化零值

step4：设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中**

step5：执行init方法

# 3. 对象的访问定位
句柄：Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。

直接指针：reference 中存储的直接就是对象的地址。

# 4. 堆空间的基本结构，什么情况下对象进入老年代
![输入图片说明](/imgs/2025-03-25/JgLtsq5dub1TnuwM.png)

大部分情况，对象首先在Eden区域分布
长期存活的对象进入老年代
大对象直接进入老年代

# 5. 如何判断对象是否死亡
引用计数法：给对象中添加一个引用计数器，每有一个地方引用它计数加一
无法解决对象之间循环引用的问题

可达性分析算法：通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
**哪些对象可以作为 GC Roots 呢？**

-   虚拟机栈(栈帧中的局部变量表)中引用的对象
-   本地方法栈(Native 方法)中引用的对象
-   方法区中类静态属性引用的对象
-   方法区中常量引用的对象
-   所有被同步锁持有的对象
-   JNI（Java Native Interface）引用的对象

# 6. 对象可以被回收，就代表一定会被回收吗？
可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。


# 垃圾回收算法
 - 标记-清除：标记和清除的效率不高，会产生不连续的内存碎片
![输入图片说明](/imgs/2025-09-18/CCl2CfuwiEfOGH3G.png)

- 复制：将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。**可用内存变小**如果存活对象数量比较大，复制性能会变得很差。
![输入图片说明](/imgs/2025-09-18/BStYupEU4xC1GkM1.png)

- 标记-整理：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景。
![输入图片说明](/imgs/2025-09-18/UZWjm764kEs0qa7f.png)

- 分代收集算法：根据各个年代的特点选择合适的垃圾收集算法。新生代（复制），老年代（标记清除，标记整理）
# 7. 垃圾收集器，各自的特点
- Serial：单线程收集器，工作室必须暂停其他所有工作线程
- ParNew：Serial的多线程版本
- Paallel Scavenge：关注点是吞吐量（高效率的利用 CPU）
#### CMS 的工作流程

CMS 的工作过程主要分为四个阶段，其中只有两个阶段需要 STW：

1.  **初始标记 (Initial Mark)** - **STW**
    
    -   一个非常短暂的暂停。
        
    -   仅标记出 GC Roots 能**直接关联**到的对象。速度非常快。
        
2.  **并发标记 (Concurrent Mark)**
    
    -   **与用户线程并发执行**，不需要暂停应用。
        
    -   从“初始标记”阶段找到的对象开始，递归地遍历整个对象图，找出所有存活的对象。
        
    -   这是最耗时的阶段，但由于是并发的，所以不影响应用运行。
        
3.  **重新标记 (Remark)** - **STW**
    
    -   一个比初始标记稍长的暂停。
        
    -   修正“并发标记”期间，因用户线程继续运行而导致标记产生变动的**那一部分对象**的标记。
        
4.  **并发清除 (Concurrent Sweep)**
    
    -   **与用户线程并发执行**，不需要暂停应用。
        
    -   清除在标记阶段被确定为死亡的对象，回收它们占用的空间。
        

#### CMS 的优点

-   **低停顿**：在整个 GC 周期中，STW 时间非常短，大部分标记和清除工作都可以和用户线程并发进行，这使得应用响应性非常好。
    

#### CMS 的致命缺点

1.  **内存碎片 (Fragmentation)**
    
    -   这是 CMS **最核心的缺陷**。由于它采用“标记-清除”算法，回收后会产生大量不连续的内存碎片。
        
    -   当需要为一个大对象分配空间时，即使老年代总空间还很足，也可能因为找不到足够大的**连续空间**而触发一次 Full GC。
        
2.  **对 CPU 资源敏感**
    
    -   并发阶段虽然不暂停应用，但会占用一部分 CPU 资源，导致应用总体的吞吐量下降。
        
3.  **无法处理“浮动垃圾” (Floating Garbage)**
    
    -   在“并发标记”阶段之后新产生的垃圾，CMS 无法在本次收集中处理它们，只能等到下一次 GC 再清理。
        
4.  **可能会发生 “Concurrent Mode Failure”**
    
    -   如果在并发清理阶段，老年代的空间不足以容纳从年轻代晋升上来的新对象，就会发生“并发模式失败”。
        
    -   一旦发生，JVM 会紧急启动后备预案：使用传统的、单线程的、STW 的 **Serial Old** 收集器来对整个老年代进行 Full GC，这会导致**非常长时间的停顿**。

#### G1 的颠覆性设计：Region 化的堆内存

G1 彻底改变了传统的分代内存布局。它将整个 Java 堆划分为多个大小相等的独立区域（Region）。每个 Region 既可以扮演年轻代（Eden, Survivor），也可以扮演老年代（Old）。

-   **优势**：这种设计使得 G1 不再需要对整个老年代进行回收。
    
-   **“Garbage-First” 的由来**：G1 会跟踪每个 Region 中垃圾的价值（即回收它能获得多少空间），并维护一个**优先列表**。在进行混合回收（Mixed GC）时，它会优先选择那些**垃圾最多、回收价值最高**的 Region 进行回收，从而在有限的时间内最大化回收效率。这就是 "Garbage-First" 的含义。
    

#### G1 的工作流程 (Mixed GC)

G1 的回收周期与 CMS 类似，也包含并发标记阶段，但回收阶段是 STW 的。

1.  **初始标记 (Initial Mark)** - **STW**
    
    -   通常伴随一次年轻代 GC (Young GC) 一起发生，暂停时间很短。
        
2.  **并发标记 (Concurrent Mark)**
    
    -   与用户线程并发执行，扫描整个堆，找出所有存活对象。
        
3.  **最终标记 (Final Mark / Remark)** - **STW**
    
    -   与 CMS 的重新标记类似，修正并发标记期间的变动。
        
4.  **筛选回收 (Live Data Counting and Evacuation)** - **STW**
    
    -   这是 G1 **最核心的阶段**。
        
    -   首先，它会对各个 Region 的回收价值进行排序。
        
    -   然后，根据用户设定的最大停顿时间，选择性地回收一部分价值最高的 Region。
        
    -   回收过程是通过**把存活对象从这些 Region 复制到其他空的 Region** 中来完成的，这个过程天然地完成了**内存整理（压缩）**。
        

#### G1 的优点

1.  **可预测的停顿模型**：用户可以指定期望的最大停顿时间，G1 会尽力满足。
    
2.  **无内存碎片**：通过复制和整理算法，G1 从根本上解决了 CMS 的内存碎片问题。
    
3.  **适用于超大堆内存**：Region 化的设计和增量回收的模式，使得 G1 非常擅长管理 G 到 T 级别的超大堆内存。


# 类加载的过程

### 阶段一：加载 (Loading)

这是类加载过程的第一步。简单来说，就是把 `.class` 文件中的**二进制数据**搬运到 JVM 内存中。

1.  **获取二进制字节流**：
    
    -   JVM 需要通过一个类的**全限定名**（如 `com.example.MyClass`）来找到并读取定义该类的**二进制字节流**。
        
    -   **途径**：字节流可以来自很多地方，最常见的是从本地硬盘的 `.class` 文件中读取，也可以来自 `.jar`、网络传输、甚至是运行时动态生成（如动态代理）。
        
2.  **转换为运行时数据结构**：
    
    -   JVM 将读取到的字节流所代表的**静态存储结构**（`.class` 文件格式）转换为**方法区**（Method Area）的运行时数据结构。方法区是用来存储类信息（如类名、字段、方法、常量池等）的地方。
        
3.  **生成 `Class` 对象**：
    
    -   在**堆内存** (Heap) 中生成一个代表这个类的 `java.lang.Class` 对象。
        
    -   这个 `Class` 对象是程序员访问方法区中类数据结构的**入口**。通过它，我们可以使用反射等功能。
        

### 阶段二：连接 (Linking)

连接阶段是把加载进来的类**进行整合和校验**，确保它可以在 JVM 中安全运行。连接又分为三个子步骤：

#### 1. 验证 (Verification)

这是确保 JVM 安全的关键步骤。目的是**验证字节流是否符合 JVM 规范**，并且不会危害 JVM 的安全。

-   **文件格式验证**：检查字节流是否符合 `.class` 文件规范，比如魔数（Magic Number）、主次版本号是否合法等。
    
-   **元数据验证**：对类的语义进行校验，比如该类是否有父类（除了 `Object` 外）、是否实现了抽象方法等。
    
-   **字节码验证**：检查程序代码的逻辑是否合法、符合规范，例如确保程序跳转到正确的指令等。
    

#### 2. 准备 (Preparation)

这个阶段是为类的**静态变量**（`static` 变量）分配内存，并设置它们的**初始值**。

-   **注意**：这里分配内存和初始化的只是**类变量**（被 `static` 修饰的变量），而不是实例变量。
    
-   **初始值**：通常是**零值**。
    
    -   `int` 类型初始化为 `0`。
        
    -   `boolean` 类型初始化为 `false`。
        
    -   引用类型（如对象）初始化为 `null`。
        
    -   **特例**：如果静态变量被 `final` 关键字修饰，且它的值是一个常量（如 `static final int VALUE = 10;`），那么在准备阶段就会直接赋值为**目标值**（10），而不是零值。
        

#### 3. 解析 (Resolution)

解析阶段是将类、方法、字段等的**符号引用**（Symbolic Reference）替换为**直接引用**（Direct Reference）的过程。

-   **符号引用**：可以理解为一个**代号**或**描述**，比如一个方法的符号引用可能是：`com.example.OtherClass.methodA(Ljava/lang/String;)V`。
    
-   **直接引用**：是直接指向目标的**内存地址或偏移量**。
    
-   **作用**：在解析后，JVM 就能根据直接引用快速定位到目标方法或变量在内存中的实际位置。
    

### 阶段三：初始化 (Initialization)

这是类加载过程的最后一步，也是 JVM 开始真正执行**类中定义的 Java 代码**的阶段。

1.  **执行 `<clinit>()` 方法**：
    
    -   **`<clinit>()`** (class initialization) 方法是编译器自动生成的，它收集了类中所有**类变量的赋值动作**和**静态代码块** (`static {}`) 中的语句。
        
    -   **核心逻辑**：按照它们在源代码中出现的顺序来执行这些语句。
        
2.  **触发条件**：
    
    -   JVM 规范规定，一个类在**首次主动使用**时，才会触发初始化。常见的主动使用情况包括：
        
        -   创建类的实例（使用 `new` 关键字）。
            
        -   访问或设置类的静态字段（除了被 `final` 修饰的常量）。
            
        -   调用类的静态方法。
            
        -   反射调用 (`Class.forName(...)`)。
            
        -   初始化一个子类时，其父类如果尚未初始化，则需要先初始化父类。

类加载器的主要作用就是动态加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）

JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载。也就是说，大部分类在具体用到的时候才会去加载，这样对内存更加友好。

对于已经加载的类会被放在 `ClassLoader` 中。在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。也就是说，对于一个类加载器来说，相同二进制名称的类只会被加载一次。

JVM 中内置了三个重要的 `ClassLoader`：

1.  **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
2.  **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
3.  **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

# 双亲委派模型
-   `ClassLoader` 类使用委托模型来搜索类和资源。
-   双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。
-   `ClassLoader` 实例会在试图亲自查找类或资源之前，将搜索类或资源的任务委托给其父类加载器。

目的：避免类的重复加载和防止核心 API 被篡改

### 打破双亲委派模型方法
Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 `WebAppClassLoader` 来打破双亲委托机制。

### 双亲委派的好处
![输入图片说明](/imgs/2025-09-23/oEenGkwkROj1kqsB.png)

# OOM与排查
### 一、 OOM发生的JVM内存区域

JVM的内存结构主要分为几个部分，其中大部分都可能发生OOM。

#### 1. Java堆 (Java Heap Space)

这是**最常见**的OOM发生区域。堆是JVM管理的最大的内存区域，用于存放几乎所有的对象实例和数组。当应用程序持续创建新对象，而垃圾收集器（GC）又无法回收足够的空间时，就会抛出 `java.lang.OutOfMemoryError: Java heap space`。

**常见原因：**

-   **内存泄漏 (Memory Leak)**：这是最主要的原因。对象在使用完毕后，仍然被某个生命周期很长的对象持有引用，导致GC无法回收它们。例如，静态集合类（如 `static HashMap`）中缓存了大量对象，但没有及时清理。
    
-   **数据量过大**：一次性从数据库查询或从文件读取大量数据到内存中，超出了堆的容量。例如，`SELECT * FROM a_very_large_table` 然后将结果全部加载到一个 `List` 中。
    
-   **堆空间设置不合理**：通过 `-Xms` 和 `-Xmx` 参数设置的堆空间过小，无法满足程序正常运行的需求。
    
-   **Finalizer滥用**：对象重写了 `finalize()` 方法，并且该方法执行缓慢或阻塞，导致 `Finalizer` 队列中的对象堆积，无法被及时回收。
    

#### 2. 元空间 (Metaspace) / 永久代 (Permanent Generation - JDK 8之前)

这个区域主要存储类的元数据信息，如类名、方法信息、字段信息、常量池等。在JDK 8及以后，永久代被元空间取代。

当系统中需要加载的类过多，或者动态生成的类（如使用CGLIB等字节码技术）过多，超出了元空间的大小时，会抛出 `java.lang.OutOfMemoryError: Metaspace` (JDK 8+) 或 `java.lang.OutOfMemoryError: PermGen space` (JDK 7-)。

**常见原因：**

-   **动态类加载过多**：大量使用反射、动态代理（CGLIB）、JSP（每个JSP文件会被编译成一个类）等技术，导致运行时生成了大量的类。
    
-   **加载的第三方库过多**：应用程序依赖的jar包非常多，导致加载的类数量巨大。
    
-   **元空间设置过小**：通过 `-XX:MaxMetaspaceSize` (或 `-XX:MaxPermSize`) 设置的元空间容量不足。
    

#### 3. 虚拟机栈 (JVM Stacks)

每个线程都有一个私有的虚拟机栈，用于存储**栈帧**（Stack Frame）。每次方法调用都会创建一个栈帧，用于存放局部变量、操作数栈、方法出口等信息。

如果线程中进行了深度过大的递归调用，或者方法内的局部变量过大，导致栈空间被耗尽，会抛出 `java.lang.StackOverflowError`。这虽然不是典型的OOM，但本质上也是一种内存耗尽。

**常见原因：**

-   **无限递归**：方法无限地调用自身，没有终止条件。这是最常见的原因。
    
-   **方法调用链过长**：程序的方法调用层次非常深。
    

#### 4. 本地方法栈 (Native Method Stacks)

与虚拟机栈类似，但它服务于 `native` 方法。这部分内存溢出比较罕见。

#### 5. 无法创建更多线程 (Unable to create new native thread)

JVM向操作系统申请创建新的线程时，如果操作系统无法再为新线程分配内存（因为每个线程都需要一定的栈空间），JVM就会抛出 `java.lang.OutOfMemoryError: unable to create new native thread`。

这严格来说不是JVM内部的某个区域内存不足，而是**JVM进程可用的总内存**受到了操作系统的限制。

#### 排查步骤
1. 开启内存快照（Heap Dump）
2. 分析Heap Dump文件，使用**Eclipse Memory Analyzer (MAT)**，功能最强大的Java堆分析工具。它可以快速计算出对象的 retained size（如果该对象被回收，能释放多少内存），并自动检测内存泄漏嫌疑。
3. 分析日志：哪个区域OOM，检查GC日志是否有异常

# 频繁FullGC排查
可能原因：对象存活率高，内存泄漏，堆结构不合理



<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MTExNjkxNSwxODUwNDkzMzk1LDQyOT
EzOTY5OSw2Mzc4MjI5NzcsLTU1ODkwNTAyLC01NDcwNjYzMSwt
NzYyNjAyNDUsMTAzNjkyNjU4OCwtMTI1MjkwNzc3Nyw4MDI0ND
Y0NjNdfQ==
-->