# 1. 说说MySQL的架构
包含Server层和存储引擎层

# 2. 一条SQL语句再MySQL中的执行过程
1. 先经过连接器（管理链接，权限验证）
2. 若命中缓存直接返回
3. 分析器（语义分析）
4. 优化器（执行计划生产，索引选择）
5. 执行器（操作引擎返回结果）

# 3. MySQL存储引擎架构了解吗
MySQL存储引擎采用插件式架构，存储引擎基于表，而不是数据库

# 4. MyISAM和InnoDB的区别
1. MyISAM只有表锁，InnoDB支持行锁
2. InnoDB支持事务
3. InnoDB支持外键
4. InnoDB支持数据库异常崩溃后的安全回复（redo log）
5. InnoDB支持MVCC
6. 索引实现不一样：InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的

# 5. 什么是事务
逻辑上的一组操作，要么都执行要么都不执行

# 6. 事务四大特性
A：Atomicity：原子性：事务是最小的执行单位，要么都执行要么都不执行
C：Consistency：一致性：执行事务前后，数据保持一致
I：Isolation：隔离性：并发访问数据库时，各并发事务之间的数据库是独立的
D：Durability：持久性：事务提交后，它对数据库的改变是持久的

AID是手段，C是目的

# 7. 并发事务带来哪些问题
- 脏读
![输入图片说明](/imgs/2025-03-25/tWf2KgMQtOVcLbjw.png)
- 丢失更改
![输入图片说明](/imgs/2025-03-25/WPKYCyKRzOoGTiqE.png)
- 不可重复读
![输入图片说明](/imgs/2025-03-25/SrcPiadr8gZ3YSUO.png)
- 幻读
![输入图片说明](/imgs/2025-03-25/yNsL8VG4EP0Zh4wp.png)

# 8. SQL定义了哪些事务隔离级别
从低到高
- 读取未提交
- 读取已提交（可阻止脏读）
- 可重复读（可阻止脏读和不可重复读）（默认）
- 可串行化：全部组织，所有的事务依次逐个执行，不互相干扰

# 9. MVCC
**MVCC的目标**：通过保存数据的多个历史版本，让不同事务在访问同一行数据时，能够看到自己应该看到的版本，从而实现**读写不加锁**
MVCC的实现依赖于三个核心组件：**隐藏字段**、**Undo Log（撤销日志）和Read View（读视图）**。
#### a. 隐藏字段

在InnoDB中，每一行数据记录除了我们能看到的列之外，还隐藏着几个非常重要的字段：

-   `DB_TRX_ID` (6字节)：记录了**创建**或**最后一次修改**该行数据的**事务ID**。
    
-   `DB_ROLL_PTR` (7字节)：一个**回滚指针**，指向该行数据上一个版本的记录，这些记录存储在Undo Log中。
    
-   `DB_ROW_ID` (6字节)：一个隐藏的、单调递增的行ID。如果表没有显式定义主键，InnoDB会用它来作为聚簇索引。
    

这些字段串联起了数据的“版本链”。

#### b. Undo Log（撤销日志 / 版本链）

Undo Log是MVCC实现多版本的关键。它主要有两个作用：一是用于事务回滚，二是构建数据版本链。

-   当一个事务对某行数据进行**修改（`UPDATE`或`DELETE`）**时，InnoDB会：
    
    1.  把该行数据**修改前的旧版本**完整地复制一份，存入 **Undo Log** 中。
        
    2.  修改当前行的数据，并更新该行的`DB_TRX_ID`为当前事务的ID。
        
    3.  将该行的`DB_ROLL_PTR`（回滚指针）指向刚才存入Undo Log中的那个旧版本记录。
        

通过`DB_ROLL_PTR`这个指针，一行数据的多个历史版本就被串联成了一个**链表**，这就是**版本链**。链表的头部是当前最新的数据。

**版本链图解：**

#### c. Read View（读视图）

“读视图”是MVCC实现**可见性判断**的核心。它解决了“一个事务在执行时，应该看到哪个版本的数据？”这个问题。

Read View本质上是事务在启动时（在`REPEATABLE READ`隔离级别下）或在每个`SELECT`语句开始时（在`READ COMMITTED`隔离级别下）创建的一个**数据快照**。这个快照记录了在创建那一刻，数据库中所有**活跃的（即未提交的）事务ID列表**。

一个Read View主要包含以下几个重要属性：

-   `m_ids`: 创建Read View时，所有活跃事务的ID列表。
    
-   `min_trx_id`: 活跃事务列表中的最小事务ID。
    
-   `max_trx_id`: 创建Read View时，系统下一个将要分配的事务ID。
    
-   `creator_trx_id`: 创建这个Read View的事务本身的ID。
    

**可见性判断规则**：当一个事务（假设其Read View为`RV`）要去读取某一行数据时，它会沿着该行数据的版本链，从最新版本开始逐一检查，直到找到一个对它**可见**的版本。判断一个版本是否可见的规则如下：

1.  比较该版本的`DB_TRX_ID`和`RV`中的属性：
    
    -   如果`DB_TRX_ID` **小于** `RV.min_trx_id`，说明这个版本在当前事务启动前**已经提交**了，所以**可见**。
        
    -   如果`DB_TRX_ID` **大于等于** `RV.max_trx_id`，说明这个版本是在当前事务启动后才开启的新事务所创建的，所以**不可见**。
        
    -   如果`DB_TRX_ID`在`RV.min_trx_id`和`RV.max_trx_id`之间，则需要下一步判断。
        
2.  继续判断：
    
    -   如果`DB_TRX_ID`**在**`RV.m_ids`（活跃事务列表）中，说明这个版本是由一个还未提交的事务所创建的，所以**不可见**。
        
    -   如果`DB_TRX_ID`**不在**`RV.m_ids`中，说明这个版本虽然在当前事务启动时还未提交，但在数据被读取时**已经提交**了，所以**可见**。
        
3.  特殊情况：
    
    -   如果`DB_TRX_ID`等于`RV.creator_trx_id`，说明是事务自己修改的记录，当然**可见**。
        

如果当前版本不可见，事务就会通过`DB_ROLL_PTR`指针，去Undo Log中寻找上一个版本，然后重复上述判断，直到找到一个可见的版本为止。

### 3. MVCC在不同隔离级别下的工作

-   **READ COMMITTED（读已提交）**：**每次**执行`SELECT`语句时，都会创建一个**新的Read View**。这保证了事务总是能读到其他事务已经提交的最新数据，但也可能导致不可重复读。
    
-   **REPEATABLE READ（可重复读）**：**只在事务开始后的第一次**`SELECT`时创建**一个Read View**，并且在整个事务期间都**复用**这个Read View。这保证了在事务内多次读取同一行数据，结果总是一致的，从而避免了不可重复读。

# 10. InnoDB有哪几类行锁
- 记录锁：单个行记录上的锁
- 间隙锁：锁定一个范围不包括记录本身
- 临键锁：锁定一个范围包括记录本身，解决幻读问题（避免插入新纪录）

# 11. 意向锁有什么作用
快速判断能否对某个表使用表锁

# 12. 索引的底层实现
B+树，只有叶子节点存放key和data，其他内节点只存放key，叶子节点有一条引用链指向相邻的叶子节点
B+树通过**高阶（即每个节点包含大量子节点）**，极大减少了树的高度，从而减少磁盘IO次数。
范围查询（比如 `SELECT * FROM user WHERE id BETWEEN 1000 AND 2000`）时，可以**从一个叶子节点顺序遍历到另一个叶子节点**，非常高效。

# 13. 主键索引和二级索引
- 主键索引：主键列使用的
- 二级索引（辅助索引）：叶子节点存储的数据是主键

# 14. 聚集索引和非聚集索引
-   聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
-   非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。

# 15. 覆盖索引
需要查询的字段正好是索引的字段，直接根据索引可以查到数据，无需回表查询

# 16. 联合索引
使用表中的多个字段创建索引

# 17. 最左前缀匹配原则
在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。
最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配

# 18. 索引下推
存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。

# 19. 如何更好地建立索引
1. 选择合适的字段作为索引（不为null，频繁查询，where条件...)
2. 尽可能建立联合索引而不是单列索引
3. 字符串类型使用前缀索引
4. 索引失效（select*，查询条件不遵守最左匹配，在索引上计算，以%开头的模糊查询）

# 20. 慢查询日志
记录执行时间超过`long_query_time`的所有查询

# 21. binlog
binlog是逻辑日志，记录语句的原始逻辑，记录了数据库中的所有变化

# 22. redo log
InnoDB独有，让MySQL拥有了崩溃恢复能力，记录某个数据页上做了什么修改。在事务提交时按照刷盘策略刷到磁盘上去

# 22. 页修改后为什么不直接刷盘
性能差，InnoDB页大小一般为16KB，频繁IO对磁盘压力大

# 23. undo log如何保证事物的原子性
每一个事务对数据的修改都会记录到undo log，可以用于回滚，属于逻辑日志，记录的是SQL语句
<!--stackedit_data:
eyJoaXN0b3J5IjpbMzkyNTg1NTg5LC00OTUwOTk3ODUsLTQ2ND
A2MDQzOF19
-->