# 1. 说说MySQL的架构
包含Server层和存储引擎层

# 2. 一条SQL语句再MySQL中的执行过程
1. 先经过连接器（管理链接，权限验证）
2. 若命中缓存直接返回
3. 分析器（语义分析）
4. 优化器（执行计划生产，索引选择）
5. 执行器（操作引擎返回结果）

# 3. MySQL存储引擎架构了解吗
MySQL存储引擎采用插件式架构，存储引擎基于表，而不是数据库

# 4. MyISAM和InnoDB的区别
1. MyISAM只有表锁，InnoDB支持行锁
2. InnoDB支持事务
3. InnoDB支持外键
4. InnoDB支持数据库异常崩溃后的安全回复（redo log）
5. InnoDB支持MVCC
6. 索引实现不一样：InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的

# 5. 什么是事务
逻辑上的一组操作，要么都执行要么都不执行

# 6. 事务四大特性
A：Atomicity：原子性：事务是最小的执行单位，要么都执行要么都不执行
C：Consistency：一致性：执行事务前后，数据保持一致
I：Isolation：隔离性：并发访问数据库时，各并发事务之间的数据库是独立的
D：Durability：持久性：事务提交后，它对数据库的改变是持久的

AID是手段，C是目的

# 7. 并发事务带来哪些问题
- 脏读
![输入图片说明](/imgs/2025-03-25/tWf2KgMQtOVcLbjw.png)
- 丢失更改
![输入图片说明](/imgs/2025-03-25/WPKYCyKRzOoGTiqE.png)
- 不可重复读
![输入图片说明](/imgs/2025-03-25/SrcPiadr8gZ3YSUO.png)
- 幻读
![输入图片说明](/imgs/2025-03-25/yNsL8VG4EP0Zh4wp.png)

# 8. SQL定义了哪些事务隔离级别
从低到高
- 读取未提交
- 读取已提交（可阻止脏读）
- 可重复读（可阻止脏读和不可重复读）（默认）
- 可串行化：全部组织，所有的事务依次逐个执行，不互相干扰

# 9. MVCC
**MVCC的目标**：通过保存数据的多个历史版本，让不同事务在访问同一行数据时，能够看到自己应该看到的版本，从而实现**读写不加锁**
MVCC的实现依赖于三个核心组件：**隐藏字段**、**Undo Log（撤销日志）和Read View（读视图）**。
#### a. 隐藏字段

在InnoDB中，每一行数据记录除了我们能看到的列之外，还隐藏着几个非常重要的字段：

-   `DB_TRX_ID` (6字节)：记录了**创建**或**最后一次修改**该行数据的**事务ID**。
    
-   `DB_ROLL_PTR` (7字节)：一个**回滚指针**，指向该行数据上一个版本的记录，这些记录存储在Undo Log中。
    
-   `DB_ROW_ID` (6字节)：一个隐藏的、单调递增的行ID。如果表没有显式定义主键，InnoDB会用它来作为聚簇索引。
    

这些字段串联起了数据的“版本链”。

#### b. Undo Log（撤销日志 / 版本链）

Undo Log是MVCC实现多版本的关键。它主要有两个作用：一是用于事务回滚，二是构建数据版本链。

-   当一个事务对某行数据进行**修改（`UPDATE`或`DELETE`）**时，InnoDB会：
    
    1.  把该行数据**修改前的旧版本**完整地复制一份，存入 **Undo Log** 中。
        
    2.  修改当前行的数据，并更新该行的`DB_TRX_ID`为当前事务的ID。
        
    3.  将该行的`DB_ROLL_PTR`（回滚指针）指向刚才存入Undo Log中的那个旧版本记录。
        

通过`DB_ROLL_PTR`这个指针，一行数据的多个历史版本就被串联成了一个**链表**，这就是**版本链**。链表的头部是当前最新的数据。

**版本链图解：**

#### c. Read View（读视图）

“读视图”是MVCC实现**可见性判断**的核心。它解决了“一个事务在执行时，应该看到哪个版本的数据？”这个问题。

Read View本质上是事务在启动时（在`REPEATABLE READ`隔离级别下）或在每个`SELECT`语句开始时（在`READ COMMITTED`隔离级别下）创建的一个**数据快照**。这个快照记录了在创建那一刻，数据库中所有**活跃的（即未提交的）事务ID列表**。

一个Read View主要包含以下几个重要属性：

-   `m_ids`: 创建Read View时，所有活跃事务的ID列表。
    
-   `min_trx_id`: 活跃事务列表中的最小事务ID。
    
-   `max_trx_id`: 创建Read View时，系统下一个将要分配的事务ID。
    
-   `creator_trx_id`: 创建这个Read View的事务本身的ID。
    

**可见性判断规则**：当一个事务（假设其Read View为`RV`）要去读取某一行数据时，它会沿着该行数据的版本链，从最新版本开始逐一检查，直到找到一个对它**可见**的版本。判断一个版本是否可见的规则如下：

1.  比较该版本的`DB_TRX_ID`和`RV`中的属性：
    
    -   如果`DB_TRX_ID` **小于** `RV.min_trx_id`，说明这个版本在当前事务启动前**已经提交**了，所以**可见**。
        
    -   如果`DB_TRX_ID` **大于等于** `RV.max_trx_id`，说明这个版本是在当前事务启动后才开启的新事务所创建的，所以**不可见**。
        
    -   如果`DB_TRX_ID`在`RV.min_trx_id`和`RV.max_trx_id`之间，则需要下一步判断。
        
2.  继续判断：
    
    -   如果`DB_TRX_ID`**在**`RV.m_ids`（活跃事务列表）中，说明这个版本是由一个还未提交的事务所创建的，所以**不可见**。
        
    -   如果`DB_TRX_ID`**不在**`RV.m_ids`中，说明这个版本虽然在当前事务启动时还未提交，但在数据被读取时**已经提交**了，所以**可见**。
        
3.  特殊情况：
    
    -   如果`DB_TRX_ID`等于`RV.creator_trx_id`，说明是事务自己修改的记录，当然**可见**。
        

如果当前版本不可见，事务就会通过`DB_ROLL_PTR`指针，去Undo Log中寻找上一个版本，然后重复上述判断，直到找到一个可见的版本为止。

### 3. MVCC在不同隔离级别下的工作

-   **READ COMMITTED（读已提交）**：**每次**执行`SELECT`语句时，都会创建一个**新的Read View**。这保证了事务总是能读到其他事务已经提交的最新数据，但也可能导致不可重复读。
    
-   **REPEATABLE READ（可重复读）**：**只在事务开始后的第一次**`SELECT`时创建**一个Read View**，并且在整个事务期间都**复用**这个Read View。这保证了在事务内多次读取同一行数据，结果总是一致的，从而避免了不可重复读。

# 10. InnoDB有哪几类行锁
- 记录锁：单个行记录上的锁
- 间隙锁：锁定一个范围不包括记录本身
- 临键锁：锁定一个范围包括记录本身，解决幻读问题（避免插入新纪录）

# 11. 意向锁有什么作用
快速判断能否对某个表使用表锁

# 12. 索引的底层实现
B+树，只有叶子节点存放key和data，其他内节点只存放key，叶子节点有一条引用链指向相邻的叶子节点
B+树通过**高阶（即每个节点包含大量子节点）**，极大减少了树的高度，从而减少磁盘IO次数。
范围查询（比如 `SELECT * FROM user WHERE id BETWEEN 1000 AND 2000`）时，可以**从一个叶子节点顺序遍历到另一个叶子节点**，非常高效。

# 13. 主键索引和二级索引
- 主键索引：主键列使用的
- 二级索引（辅助索引）：叶子节点存储的数据是主键

# 14. 聚集索引和非聚集索引
-   聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。
-   非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引（辅助索引）就属于非聚簇索引。

# 聚簇索引是哪一列
因此，每张 InnoDB 表**有且只有一个**聚簇索引。
-   **主键 (PRIMARY KEY)**：如果表定义了主键，那么主键就是聚簇索引。
    
-   **第一个唯一非空索引 (UNIQUE NOT NULL Index)**：如果表没有定义主键，InnoDB 会选择第一个所有列都定义为 `NOT NULL` 的 `UNIQUE` 索引作为聚簇索引。
    
-   **隐藏的内部列 (GEN_CLUST_INDEX)**：如果以上两者都不存在，InnoDB 会在内部自动创建一个名为 `GEN_CLUST_INDEX` 的隐藏聚簇索引，它建立在一个包含行 ID 值的 6 字节的隐藏列上。这个索引对用户是不可见的。

# 15. 覆盖索引
需要查询的字段正好是索引的字段，直接根据索引可以查到数据，无需回表查询

# 16. 联合索引
使用表中的多个字段创建索引

# 17. 最左前缀匹配原则
在使用联合索引时，MySQL 会根据索引中的字段顺序，从左到右依次匹配查询条件中的字段。如果查询条件与索引中的最左侧字段相匹配，那么 MySQL 就会使用索引来过滤数据，这样可以提高查询效率。
最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配

# 18. 索引下推
存储引擎在索引遍历过程中，执行部分 `WHERE` 字句的判断条件，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率。

# 19. 如何更好地建立索引
1. 选择合适的字段作为索引（不为null，频繁查询，where条件...)
2. 尽可能建立联合索引而不是单列索引
3. 字符串类型使用前缀索引
4. 索引失效（select*，查询条件不遵守最左匹配，在索引上计算，以%开头的模糊查询）

# 20. 慢查询日志
记录执行时间超过`long_query_time`的所有查询

# 21. binlog
binlog是逻辑日志，记录语句的原始逻辑，记录了数据库中的所有变化，属于MySQL Service层
数据库的主从备份依靠binlog

# 22. redo log
InnoDB独有，让MySQL拥有了崩溃恢复能力，记录某个数据页上做了什么修改。在事务提交时按照刷盘策略刷到磁盘上去

# undo log
每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。

undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE/DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。
另外，`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。


# 22. 页修改后为什么不直接刷盘
性能差，InnoDB页大小一般为16KB，频繁IO对磁盘压力大

# 23. undo log如何保证事物的原子性
每一个事务对数据的修改都会记录到undo log，可以用于回滚，属于逻辑日志，记录的是SQL语句

# 为什么用B+树
### 数据结构选型之旅（排除法）

让我们看看为什么其他常见的数据结构不适合做数据库索引。

#### 1. 为什么不用哈希表 (Hash Table)？

-   **优点**：在进行**等值查询**（例如 `WHERE id = 100`）时，哈希表的效率极高，时间复杂度为 O(1)。
    
-   **致命缺点**：
    
    -   **无法进行范围查询**：哈希表是无序的。对于 `WHERE age > 25` 或 `ORDER BY create_time` 这样的范围查询和排序操作，哈希表无能为力，只能退化为全表扫描。
        
    -   数据库中范围查询和排序是非常常见的场景，因此哈希表不适用。
        

#### 2. 为什么不用二叉搜索树 (BST) 或平衡二叉树 (AVL, Red-Black Tree)？

-   **优点**：它们是有序的，支持范围查询，且查询效率在 O(log N)，看起来不错。
    
-   **致命缺点**：**树的高度太高，导致 I/O 次数过多**。
    
    -   二叉树每个节点最多只有两个子节点。当数据量巨大时（例如千万、上亿条记录），树的高度会非常可观。
        
    -   在数据库中，**每访问一个树节点，都可能对应一次磁盘 I/O**。如果一棵树的高度是 `h`，那么一次查询最多可能需要 `h` 次磁盘 I/O。
        
    -   以一棵存储百万条记录的平衡二叉树为例，其高度大约是 20 (`log₂(1,000,000) ≈ 20`)。这意味着一次查询最坏可能需要 20 次磁盘 I/O，这对于数据库来说是无法接受的。
        

_<center>二叉树“高瘦”，B+树“矮胖”，后者大大减少了I/O次数</center>_

### B+ 树的崛起：为磁盘 I/O 而生的数据结构

为了解决上述问题，B+ 树应运而生。它对传统的树形结构进行了改造，使其变得“**矮胖**”，完美地适应了磁盘的读写特性。

#### B+ 树的特性与优势

1.  **多路分支，高度极低 (矮胖)**
    
    -   B+ 树不再是二叉树，而是**多叉树**。一个父节点可以拥有成百上千个子节点。
        
    -   这使得树的高度被**急剧压缩**。一棵存储千万条记录的 B+ 树，其高度通常只有 **3 到 4 层**。
        
    -   这意味着，无论查询任何数据，最多只需要 3 到 4 次磁盘 I/O，查询性能非常稳定且高效。
        
2.  **非叶子节点只存储键值和指针，不存数据**
    
    -   这是 B+ 树相较于其前身 B 树的一个关键优化。
        
    -   由于非叶子节点（内部节点）不存储实际的数据行（row data），只存储索引键（key）和指向下一层节点的指针（pointer），这使得**每个节点可以容纳更多的索引键**。
        
    -   一个节点能容纳的索引键越多，树的分叉就越多，树的高度就越低。
        
    -   **InnoDB 中一个节点的大小通常默认为 16KB**，这与磁盘页（Page）的大小相对应，一次 I/O 就可以将整个节点的数据加载到内存中。
        
3.  **所有数据都存储在叶子节点**
    
    -   所有的数据记录都完整地存放在叶子节点层。
        
    -   这带来了两个好处：
        
        -   **查询性能稳定**：任何一次数据查询，都必须从根节点走到叶子节点，所经过的 I/O 次数是相同的。
            
        -   **全表扫描更方便**：由于数据都在叶子层，进行全表扫描时，只需遍历叶子节点链表即可，无需遍历整棵树。
            
4.  **叶子节点之间通过双向链表连接**
    
    -   这是 B+ 树的另一个“神来之笔”，**极大地优化了范围查询**。
        
    -   当执行一个范围查询（例如 `WHERE age BETWEEN 20 AND 30`）时，数据库首先通过树的根节点找到范围的起始点（age=20 所在的叶子节点），然后**直接通过叶子节点之间的链表向后遍历**，直到范围结束。
        
    -   这个过程不再需要回溯到父节点，大大提高了范围查询和排序操作的效率。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgyMjA2NzI4NiwxMDkxNTE0NzY0LC02MT
gzNDgyODAsMzkyNTg1NTg5LC00OTUwOTk3ODUsLTQ2NDA2MDQz
OF19
-->