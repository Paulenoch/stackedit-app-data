# IOC，控制反转
IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理
-   **控制**：指的是对象创建（实例化、管理）的权力
-   **反转**：控制权交给外部环境（Spring 框架、IoC 容器）

将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。

在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。

# Spring Bean

Bean 代指的就是那些被 IoC 容器所管理的对象。

### Bean的生命周期
实例化——属性赋值——初始化——销毁
![输入图片说明](/imgs/2025-04-08/6LcooDzFRf5DpS3l.png)

### 注入Bean的方式
1. 构造函数注入：通过类的构造函数注入
2. Setter注入：通过类的Setter方法注入
3. Field（字段）注入，直接在类的字段上使用注解（@Autowired，@Resource）注入

推荐构造函数注入：依赖完整性，不可变，初始化保证，测试便利

# Spring IOC容器的创建
1. 加载配置文件，配置文件包含了应用程序中各个Bean的定义及它们之间的依赖关系
2. 实例化容器：IOC容器会实例化并初始化自身，这个阶段容器会读取配置文件中的Bean定义，并根据这些定义创建相应的bean实例
3. 实例化Bean：容器根据配置文件中Bean定义，利用反射机制实例化Bean对象
4. 注入依赖：Bean对象被实例化之后，根据配置文件中的依赖关系，将相应的依赖注入Bean中
5. 初始化Bean，调用Bean的初始化方法
6. 容器就绪

# Spring AOP
AOP 的目的是将横切关注点（如日志记录、事务管理、权限控制、接口限流、接口幂等等）从核心业务逻辑中分离出来，通过动态代理、字节码操作等技术，实现代码的复用和解耦，提高代码的可维护性和可扩展性。OOP 的目的是将业务逻辑按照对象的属性和行为进行封装，通过类、对象、继承、多态等概念，实现代码的模块化和层次化（也能实现代码的复用），提高代码的可读性和可维护性。

# SpringBoot自动装配

没有 Spring Boot 的情况下，如果我们需要引入第三方依赖，需要手动配置，非常麻烦。但是，Spring Boot 中，我们直接引入一个 starter 即可。比如你想要在项目中使用 redis 的话，直接在项目中引入对应的 starter 即可。

引入 starter 之后，我们通过少量注解和一些简单的配置就能使用第三方组件提供的功能了。

在我看来，自动装配可以简单理解为：**通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。**

SpringBoot的核心注解`@SpringBootApplication`
由`@Configuration`、`@EnableAutoConfiguration`、`@ComponentScan` 组成
-   `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
-   `@Configuration`：允许在上下文中注册额外的 bean 或导入其他配置类
-   `@ComponentScan`：扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除`TypeExcludeFilter`和`AutoConfigurationExcludeFilter`。

# Spring框架中哪些功能依赖反射实现
### 1. **依赖注入（Dependency Injection）**

-   Spring在容器启动时，会扫描Bean定义，然后**通过反射实例化对象（调用构造方法）**。
    
-   给对象**注入字段（Field）**、**调用Setter方法**，也是通过反射来访问和修改私有成员的。

### 2. **AOP（面向切面编程，Aspect Oriented Programming）**

-   Spring AOP 需要**动态代理对象**，而生成代理时（尤其是基于JDK动态代理或者CGLIB字节码增强）需要通过反射调用原方法。
    
-   方法拦截（MethodInterceptor）也是通过反射调用目标方法。

### 3. **事务管理（@Transactional）**

-   Spring事务是基于AOP实现的，本质上也是通过反射**拦截方法调用**，在调用目标方法前后进行事务管理（开启事务、提交、回滚）。

### 6. **注解处理（@Autowired, @Qualifier, @Value, @Component, @Service 等）**

-   Spring使用反射去**读取类、方法、字段上的注解**，然后根据注解的元数据做各种自动化处理，比如自动注入、条件装配。

# SpringAOP中，动态代理的两种实现方式
### 1. **JDK动态代理**

-   基于**接口**进行代理。
    
-   代理对象会**实现目标对象的接口**，然后通过`InvocationHandler`来拦截方法调用。

### 2. **CGLIB动态代理**

-   基于**继承（子类化）**进行代理。
    
-   CGLIB通过**生成目标类的子类**，重写方法来实现拦截。

# Spring事务失效
**方法自调用（Self-Invocation）**

这是最常见也是最典型的AOP注解失效场景。当一个Bean的内部方法A调用同一个Bean的另一个被注解（如 `@Transactional`）的方法B时，这个调用是通过 `this` 关键字直接发生的，绕过了Spring的代理对象。因此，方法B的增强逻辑（如事务）不会被执行。
解决方案：**注入自身代理对象**：将Bean自身注入，并使用注入的代理对象来调用方法。

-   **方法的访问权限问题**：`@Transactional` 等AOP注解所修饰的方法必须是 `public` 的。因为代理机制无法拦截 `private`、`protected` 或 `default` 权限的方法。
    
-   **方法被 `final` 修饰**：如果一个方法被 `final` 修饰，它将无法被子类（CGLIB代理）重写，因此AOP增强会失效。同理，如果类被 `final` 修饰，整个类都无法被代理。
    
-   **异常被内部 `try-catch` 捕获**：在使用 `@Transactional` 时，如果方法内部将异常捕获并且没有重新抛出，Spring的事务管理器将无法感知到异常，从而导致事务不会回滚。

# Spring中事务传播行为
它定义了**当一个带有事务配置的方法被另一个方法调用时，事务应该如何传播和管理**
简单来说，就是当方法 A 调用方法 B，而 A 和 B 都可能配置了事务时，Spring 需要一套规则来决定 B 方法应该运行在哪个事务中——是加入 A 的事务，还是开启一个自己的新事务，或者以非事务方式运行等等。这些规则通过在 `@Transactional` 注解的 `propagation` 属性中设置。

#### 第一类：支持当前事务（这是最常用的）

**1. `REQUIRED` (默认值)**

-   **含义**：如果当前存在一个事务，那么该方法就会**加入**到这个事务中执行。如果当前不存在事务，那么它会为自己**创建一个新**的事务。
    
-   **比喻**：就像参加一个团队项目。如果已经有一个项目团队（当前事务）在运作，你就加入他们一起干。如果还没有团队，你就自己组建一个新团队（创建新事务）来完成任务。
    
-   **特点**：这是最常用、最典型的传播行为。它能保证多个方法在同一个事务中执行，要么一起成功，要么一起失败。
    
-   **场景**：绝大多数的增、删、改操作。例如，一个 `updateOrder()` 方法调用 `decreaseStock()` 方法，这两个方法需要保证在同一个事务内，以确保数据一致性。
    

**2. `SUPPORTS`**

-   **含义**：如果当前存在一个事务，那么该方法就会**加入**到这个事务中执行。如果当前不存在事务，那么它会以**非事务**的方式执行。
    
-   **比喻**：一个随和的顾问。如果团队在开会讨论（当前事务），他就加入一起讨论。如果大家都在各自工作（没有事务），他也就自己独立工作，不发起会议。
    
-   **特点**：它不会自己主动开启事务。
    
-   **场景**：主要用于那些不修改数据，但可能涉及在同一个事务中读取最新数据的查询操作。比如，你有一个查询方法，如果它在一个正在进行更新操作的事务中被调用，你希望它能读到该事务中尚未提交的数据。
    

**3. `MANDATORY`**

-   **含义**：强制要求当前**必须存在**一个事务，否则就会抛出异常。它自己**不会**创建事务。
    
-   **比喻**：一个严格的质检员，他只在生产线（当前事务）运行时才工作。如果生产线停了，他会立刻报告错误（抛异常），而不是自己启动生产线。
    
-   **特点**：用于强调某个方法必须在事务中被调用，以确保数据操作的原子性。
    
-   **场景**：通常用于一些核心的、非独立的业务模块，这些模块的功能必须依赖于一个已经开启的事务上下文。比如一个记录资金流水的内部方法，它绝不能在没有事务的情况下被独立调用。
    

#### 第二类：不支持当前事务

**4. `REQUIRES_NEW`**

-   **含义**：无论当前是否存在事务，它都会**创建一个全新的事务**来执行。如果当前存在事务，它会把当前事务**挂起**（pause），执行完自己的新事务后，再恢复被挂起的事务。
    
-   **比喻**：一个有独立决策权的总监。不管公司大会（外部事务）开到什么程度，他接到一项紧急任务时，会立刻召集自己的团队开一个小会（创建新事务）。小会开完，他再回去继续参加公司大会。
    
-   **特点**：内外两个事务是完全独立的。内部事务的回滚不会影响外部事务，反之亦然。
    
-   **场景**：
    
    -   希望某个操作的结果**不因外部事务的回滚而受到影响**。例如，在一个复杂的业务流程中，无论主流程成功与否，都需要记录一条操作日志到数据库。这时，日志记录方法就可以使用 `REQUIRES_NEW`。
        
    -   内部事务的提交需要独立于外部事务。
        

**5. `NOT_SUPPORTED`**

-   **含义**：以**非事务**的方式执行操作。如果当前存在事务，它会把当前事务**挂起**。
    
-   **比喻**：一个需要“绝对安静”环境工作的专家。如果有人在开会（当前事务），他会请他们暂停，然后自己以独立、不受干扰的方式完成工作，之后再让他们继续开会。
    
-   **特点**：保证了该方法内部的数据库操作不会参与任何事务。
    
-   **场景**：
    
    -   某些操作非常耗时，并且不要求事务性，将其放入事务中会长时间占用数据库连接，影响性能。
        
    -   调用一些非事务性的第三方服务或执行一些与数据库事务无关的操作。
        

**6. `NEVER`**

-   **含义**：强制要求当前**必须不存在**事务，否则就会抛出异常。
    
-   **比喻**：一个只能在“非会议时间”工作的维护人员。如果他发现有人在开会（当前事务），他会立即拒绝工作并提出警告（抛异常）。
    
-   **特点**：与 `MANDATORY` 完全相反，确保方法不会在事务中被误调用。
    
-   **场景**：用于一些初始化、数据同步等批量处理任务，这些任务设计上就不应该被包含在任何客户端发起的事务中。
    

#### 第三类：嵌套事务

**7. `NESTED`**

-   **含义**：如果当前存在一个事务，它会创建一个**嵌套事务**（Savepoint）。如果当前不存在事务，它的行为就和 `REQUIRED` 一样，创建一个新事务。
    
-   **比喻**：项目组长在一个大项目（外部事务）中设立了一个“里程碑”（Savepoint）。团队在这个里程碑之后进行了一些尝试（内部嵌套事务），如果这些尝试失败了，他们可以只**回滚到这个里程碑**，而不需要把整个项目都推倒重来。但是，如果整个大项目最终失败了，那么这个里程碑之后的所有努力也都会付之东流。
    
-   **与 `REQUIRES_NEW` 的关键区别**：
    
    -   **独立性**：`REQUIRES_NEW` 创建的是一个完全独立的事务。`NESTED` 创建的子事务依赖于外部事务。
        
    -   **回滚**：`NESTED` 的内部事务回滚不影响外部事务。但**外部事务的回滚会导致内部事务也一起回滚**。而 `REQUIRES_NEW` 的内外事务回滚互不影响。
        
    -   **提交**：`NESTED` 的内部事务在执行完毕后并不会立即提交，它需要等待外部事务一起提交。
        
-   **场景**：适用于那些复杂的、可部分回滚的业务场景。例如，一个批量插入用户的操作，其中某个用户因为数据格式问题插入失败，你希望只回滚这一个用户的插入操作，而不影响其他已经成功的用户。
    
-   **注意**：`NESTED` 行为依赖于数据库驱动是否支持**保存点（Savepoint）** 功能。大多数主流数据库（如 Oracle, SQL Server, PostgreSQL）都支持，但 MySQL 的某些存储引擎（如 MyISAM）则不支持。

# Spring中的Bean是单例的还是多例的
### 1. 单例 (Singleton) - 默认作用域

当一个 Bean 的作用域被定义为单例时，**Spring IoC 容器中只会存在这一个 Bean 的实例**。无论你通过什么方式（如 `@Autowired` 注入或 `context.getBean()` 获取）请求这个 Bean，得到的都是指向**同一个**对象的引用。

**特点：**

-   **全局唯一**：在整个应用的生命周期中，容器只创建一次该 Bean 的实例。
    
-   **性能开销小**：由于不需要频繁创建和销毁对象，所以资源占用较少。
    
-   **线程不安全（如果 Bean 有状态）**：因为所有线程共享同一个实例，如果 Bean 中存在可变的成员变量（即有状态的 Bean），在多线程环境下可能会引发线程安全问题。因此，绝大部分 Service、DAO (Repository)、Controller 等都是无状态的，非常适合设计为单例。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MTg4MTc1NzUsNzc5Njc4NjA2LDQxMz
A2NzM5NiwxODM2MDI0Njk2LC04ODY3MTY3MjcsNTAwMTc0NDI1
LDE3MTI3NTU5OTFdfQ==
-->