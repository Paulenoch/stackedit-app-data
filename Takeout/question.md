# 1. Nginx反向代理
**nginx 反向代理的好处：**

-   提高访问速度：因为nginx本身可以进行缓存，如果访问的同一接口，并且做了数据缓存，nginx就直接可把数据返回，不需要真正地访问服务端，从而提高访问速度。
-   进行负载均衡
-   保证后端服务安全：因为一般后台服务地址不会暴露，所以使用浏览器不能直接访问，可以把nginx作为请求访问的入口，请求到达nginx后转发到具体的服务中，从而保证后端服务的安全。

**负载均衡**
nginx有很多负载均衡策略，比如轮询（默认），weight权重方式,url分配方式，我们项目用的是轮询方式，共有3台后端服务器

# 2. 实现布隆过滤器解决缓存穿透问题
## 2.1 什么是缓存穿透
缓存穿透:请求根本不存在的资源（DB本身就不存在，Redis更是不存在），这将导致这个不存在的数据每次请求都要到 DB 去查询，可能导致 DB 挂掉

## 2.2 什么是布隆过滤器
布隆过滤器主要是用于检索一个元素是否在一个集合中。

布隆过滤器的核心思想是使用多个哈希函数来将元素映射到**位数组**中的多个位置上。当一个元素被加入到布隆过滤器中时，它会被多次哈希，并`将对应的位数组位置设置为1`。当需要判断一个元素是否在布隆过滤器中时，我们只需将该元素进行多次哈希，并检查对应的位数组位置是否都为1，如果`其中有任意一位为0，则说明该元素不在集合中`；如果所有位都为1，则说明该元素`可能`在集合中（因为有可能存在哈希冲突），需要进一步检查。

使用BitMap作为布隆过滤器，使用多个hash函数对key进行hash运算

当布隆过滤器实际的数据存储量超过预期数据量之后，误判率也会随之上涨。但是布隆过滤器是不能删除已有元素的，在这里我们采取的方案是再创建一个布隆过滤器

# 3. MySQL主从复制，读写分离
主从复制实际上就是将主库的数据同步到从库数据，通过Mysql主从复制就可以实现从库中的数据和主库中的数据一致。MySQL复制过程分为三步：

第一：主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。

第二：从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。

第三：从库重做中继日志中的事件，在slave库上做相应的更改。

### Sharding-JDBC怎么实现读写分离

对于同一时刻有大量并发读操作和较少写操作类型的应用来说，将数据库拆分为主库和从库，主库就负责处理事务性的增删改操作，从库负责处理查询操作，能够有效的避免由数据更新导致的行锁（innodb引擎支持的就是行锁），使得整个系统的性能得到极大改善。

Sharding-JDBC介绍Sharding-JDBC定位为轻量级java框架，在java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。使用Sharding-JDBC可以在程序中轻松的实现数据库读写分离,优点在于数据源完全有Sharding托管，写操作自动执行master库，读操作自动执行slave库。不需要程序员在程序中关注这个实现了。

# 4. 使用Redis，采用一主两从＋哨兵的集群方案

### 4.1 为什么用Redis
频繁的访问数据库导致数据库压力大，系统的性能下降，用户体验感差。因此使用Redis对数据进行缓存，从而减小数据库的压力，在数据更新时删除缓存，从而保证数据库和缓存的一致性，同时有效提高系统的性能和访问速度。

### 为什么采用一主两从+哨兵
单Redis的并发能力是有上限的，搭建主从集群实现读写分离。主节点负责写数据，从节点负责读数据（解决高并发问题）

主数据库若崩溃。哨兵作为一个独立运行的进程，通过发送ping命令等待Redis服务器响应，从而监控运行的多个Redis实例。当检测到master宕机，会自动将slave切换成master。通过发布订阅模式通知其他slave修改配置文件，让它们切换master
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3MTQ3OTM0OCwyMDgzMzg3NzE2LDE0OT
Y1MzI2MDRdfQ==
-->