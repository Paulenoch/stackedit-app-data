##  一、先把“大图景”理顺：一次抽奖时都发生了什么？

1.  入口在抽象类 `AbstractRaffleStrategy#performRaffle`：
    

-   校验参数 → 查策略 → **调用“抽奖前规则过滤”** → 根据过滤结果决定“是否接管抽奖/如何接管” → 否则走默认抽奖。
    
-   如果前置规则返回“接管”(TAKE_OVER)：
    
    -   命中黑名单：直接返回预设的奖品 ID；
        
    -   命中权重：拿到“权重范围 Key”，在这个范围内抽；
        
    -   否则默认按整套策略随机抽。
        

2.  “抽奖前规则过滤”的**真实执行者**是默认实现 `DefaultRaffleStrategy#doCheckRaffleBeforeLogic`：
    

-   它先向“规则工厂”要到所有规则实现（按 code -> 规则实现 的 Map）；
    
-   **黑名单优先**（如果配置里含黑名单就先判它）；
    
-   再按顺序跑剩余的规则（比如权重），只要有一个规则“不放行”(不是 ALLOW) 就**立即返回**该结果。
    

3.  “规则工厂” `DefaultLogicFactory` 的职责：
    

-   在 Spring 启动时把所有打了 `@LogicStrategy` 注解的规则（实现了 `ILogicFilter`）**自动注册**到 Map（key = 规则 code）；
    
-   同时把“规则编码”的枚举（黑名单/权重）定义在一起，供全局使用。
    

> 小结：一次抽奖会“先跑前置规则”，有规则接管就按规则来（黑名单直给奖品；权重在限定范围内抽），没人接管就按默认策略抽。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE4MzcxMTg3OSwtMjA4ODc0NjYxMl19
-->