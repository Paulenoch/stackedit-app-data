#  一、先把“大图景”理顺：一次抽奖时都发生了什么？

1.  入口在抽象类 `AbstractRaffleStrategy#performRaffle`：
    

-   校验参数 → 查策略 → **调用“抽奖前规则过滤”** → 根据过滤结果决定“是否接管抽奖/如何接管” → 否则走默认抽奖。
    
-   如果前置规则返回“接管”(TAKE_OVER)：
    
    -   命中黑名单：直接返回预设的奖品 ID；
        
    -   命中权重：拿到“权重范围 Key”，在这个范围内抽；
        
    -   否则默认按整套策略随机抽。
        

2.  “抽奖前规则过滤”的**真实执行者**是默认实现 `DefaultRaffleStrategy#doCheckRaffleBeforeLogic`：
    

-   它先向“规则工厂”要到所有规则实现（按 code -> 规则实现 的 Map）；
    
-   **黑名单优先**（如果配置里含黑名单就先判它）；
    
-   再按顺序跑剩余的规则（比如权重），只要有一个规则“不放行”(不是 ALLOW) 就**立即返回**该结果。
    

3.  “规则工厂” `DefaultLogicFactory` 的职责：
    

-   在 Spring 启动时把所有打了 `@LogicStrategy` 注解的规则（实现了 `ILogicFilter`）**自动注册**到 Map（key = 规则 code）；
    
-   同时把“规则编码”的枚举（黑名单/权重）定义在一起，供全局使用。
    

> 小结：一次抽奖会“先跑前置规则”，有规则接管就按规则来（黑名单直给奖品；权重在限定范围内抽），没人接管就按默认策略抽。

# 二、逐个文件讲“它是谁、做什么、关键实现在哪”

## 1) 规则工厂：`DefaultLogicFactory`（service/rule/factory）

**作用**：扫描所有被 `@LogicStrategy` 标注的规则实现，按规则编码登记到 `logicFilterMap`，并提供 `openLogicFilter()` 让业务方取用。  
**关键点**：

-   使用 `AnnotationUtils.findAnnotation` 找到每个实现类的 `@LogicStrategy`，然后 `logicMode().getCode()` 作为 Map 的 key。
    
-   `openLogicFilter()` 返回的是一个**带泛型转换**的 Map（对上层是类型安全的）。
    
-   `LogicModel` 定义了两个规则：`rule_weight`（按积分→限定奖池范围）与 `rule_blacklist`（黑名单命中就接管）。
    

## 2) 抽奖策略：`DefaultRaffleStrategy`（service/raffle）

**作用**：实现“**如何串规则**”——黑名单优先，其它规则按序执行。  
**关键点**：

-   先拿到 `logicFactory.openLogicFilter()`（即 code→规则实现 的表）。
    
-   **黑名单优先**：只要策略配置中包含黑名单，就先组 `RuleMatterEntity` 去跑黑名单的 `filter`；如果结果不是 ALLOW（即接管），直接返回。
    
-   **顺序执行剩余规则**（过滤掉黑名单后）：依次调用每个 `ILogicFilter#filter`，出现任一“非放行”（接管/拦截）立即返回。
    

> PS：这个类**只做编排**，并不决定“给谁抽/抽哪些”——这些逻辑在具体规则里。

## 3) 黑名单规则：`RuleBlackListLogicFilter`（service/rule/impl）

**作用**：如果用户在黑名单里，则**直接接管**并返回一个“固定奖品 ID”。  
**关键点**：

-   通过 `@LogicStrategy(logicMode = RULE_BLACKLIST)` 与规则工厂对接。
    
-   从仓储 `IStrategyRepository` 查询“规则值”（字符串），格式形如：`<awardId>:<userId1, userId2, ...>`；先取冒号左边转成 `awardId`，右边按分隔符拆成黑名单用户集合。只要当前用户命中，就返回 `TAKE_OVER` + `awardId`。没命中就返回 `ALLOW`。
    

## 4) 权重规则：`RuleWeightLogicFilter`（service/rule/impl）

**作用**：按照用户“积分（或等级等）”落在哪个阈值段，**限定可抽奖品的范围**，再把这个范围 Key 交给后续抽奖引擎。  
**关键点**：

-   通过 `@LogicStrategy(logicMode = RULE_WIGHT)` 接入工厂（注意：拼写是 `WIGHT`）。
    
-   规则值格式（示例）：  
    `4000:102,103,104,105 5000:102,103,104,105,106,107 6000:102,103,104,105,106,107,108,109`  
    即用空格分隔若干“阈值:奖品ID列表”的片段。先查询规则值，再解析成 `Map<Long /*阈值*/, String /*原片段*/>`。
    
-   解析后把 key（阈值）排序，**找出满足 `userScore >= 阈值` 的片段**，返回 `TAKE_OVER` + `ruleWeightValueKey`（就是原片段字符串，后面抽奖引擎靠它来限定候选奖品集）。
    
-   若解析为空或没找到匹配阈值，返回 `ALLOW`（不接管）。
    

## 5) 抽奖模板父类：`AbstractRaffleStrategy`（service/raffle）

**作用**：定义抽奖的**主流程**与“接管”分支决策。  
**关键点**：

-   参数校验 → 取策略（里面带着规则配置）→ **把策略里的规则数组一起丢给 `doCheckRaffleBeforeLogic`**。
    
-   如果前置规则**接管**：
    
    -   黑名单：直接用规则结果里的 `awardId` 结束；
        
    -   权重：拿 `ruleWeightValueKey` 交给 `strategyDispatch.getRandomAwardId(strategyId, ruleWeightValueKey)` 在限定范围内抽。
        
    -   否则：走默认 `strategyDispatch.getRandomAwardId(strategyId)`。
<!--stackedit_data:
eyJoaXN0b3J5IjpbOTc5MjI3NjgwLC0yMDg4NzQ2NjEyXX0=
-->