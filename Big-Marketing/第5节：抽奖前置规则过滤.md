#  一、先把“大图景”理顺：一次抽奖时都发生了什么？

1.  入口在抽象类 `AbstractRaffleStrategy#performRaffle`：
    

-   校验参数 → 查策略 → **调用“抽奖前规则过滤”** → 根据过滤结果决定“是否接管抽奖/如何接管” → 否则走默认抽奖。
    
-   如果前置规则返回“接管”(TAKE_OVER)：
    
    -   命中黑名单：直接返回预设的奖品 ID；
        
    -   命中权重：拿到“权重范围 Key”，在这个范围内抽；
        
    -   否则默认按整套策略随机抽。
        

2.  “抽奖前规则过滤”的**真实执行者**是默认实现 `DefaultRaffleStrategy#doCheckRaffleBeforeLogic`：
    

-   它先向“规则工厂”要到所有规则实现（按 code -> 规则实现 的 Map）；
    
-   **黑名单优先**（如果配置里含黑名单就先判它）；
    
-   再按顺序跑剩余的规则（比如权重），只要有一个规则“不放行”(不是 ALLOW) 就**立即返回**该结果。
    

3.  “规则工厂” `DefaultLogicFactory` 的职责：
    

-   在 Spring 启动时把所有打了 `@LogicStrategy` 注解的规则（实现了 `ILogicFilter`）**自动注册**到 Map（key = 规则 code）；
    
-   同时把“规则编码”的枚举（黑名单/权重）定义在一起，供全局使用。
    

> 小结：一次抽奖会“先跑前置规则”，有规则接管就按规则来（黑名单直给奖品；权重在限定范围内抽），没人接管就按默认策略抽。

# 二、逐个文件讲“它是谁、做什么、关键实现在哪”

## 1) 规则工厂：`DefaultLogicFactory`（service/rule/factory）

**作用**：扫描所有被 `@LogicStrategy` 标注的规则实现，按规则编码登记到 `logicFilterMap`，并提供 `openLogicFilter()` 让业务方取用。  
**关键点**：

-   使用 `AnnotationUtils.findAnnotation` 找到每个实现类的 `@LogicStrategy`，然后 `logicMode().getCode()` 作为 Map 的 key。
    
-   `openLogicFilter()` 返回的是一个**带泛型转换**的 Map（对上层是类型安全的）。
    
-   `LogicModel` 定义了两个规则：`rule_weight`（按积分→限定奖池范围）与 `rule_blacklist`（黑名单命中就接管）。
    

## 2) 抽奖策略：`DefaultRaffleStrategy`（service/raffle）

**作用**：实现“**如何串规则**”——黑名单优先，其它规则按序执行。  
**关键点**：

-   先拿到 `logicFactory.openLogicFilter()`（即 code→规则实现 的表）。
    
-   **黑名单优先**：只要策略配置中包含黑名单，就先组 `RuleMatterEntity` 去跑黑名单的 `filter`；如果结果不是 ALLOW（即接管），直接返回。
    
-   **顺序执行剩余规则**（过滤掉黑名单后）：依次调用每个 `ILogicFilter#filter`，出现任一“非放行”（接管/拦截）立即返回。
    

> PS：这个类**只做编排**，并不决定“给谁抽/抽哪些”——这些逻辑在具体规则里。

## 3) 黑名单规则：`RuleBlackListLogicFilter`（service/rule/impl）

**作用**：如果用户在黑名单里，则**直接接管**并返回一个“固定奖品 ID”。  
**关键点**：

-   通过 `@LogicStrategy(logicMode = RULE_BLACKLIST)` 与规则工厂对接。
    
-   从仓储 `IStrategyRepository` 查询“规则值”（字符串），格式形如：`<awardId>:<userId1, userId2, ...>`；先取冒号左边转成 `awardId`，右边按分隔符拆成黑名单用户集合。只要当前用户命中，就返回 `TAKE_OVER` + `awardId`。没命中就返回 `ALLOW`。
    

## 4) 权重规则：`RuleWeightLogicFilter`（service/rule/impl）

**作用**：按照用户“积分（或等级等）”落在哪个阈值段，**限定可抽奖品的范围**，再把这个范围 Key 交给后续抽奖引擎。  
**关键点**：

-   通过 `@LogicStrategy(logicMode = RULE_WIGHT)` 接入工厂（注意：拼写是 `WIGHT`）。
    
-   规则值格式（示例）：  
    `4000:102,103,104,105 5000:102,103,104,105,106,107 6000:102,103,104,105,106,107,108,109`  
    即用空格分隔若干“阈值:奖品ID列表”的片段。先查询规则值，再解析成 `Map<Long /*阈值*/, String /*原片段*/>`。
    
-   解析后把 key（阈值）排序，**找出满足 `userScore >= 阈值` 的片段**，返回 `TAKE_OVER` + `ruleWeightValueKey`（就是原片段字符串，后面抽奖引擎靠它来限定候选奖品集）。
    
-   若解析为空或没找到匹配阈值，返回 `ALLOW`（不接管）。
    

## 5) 抽奖模板父类：`AbstractRaffleStrategy`（service/raffle）

**作用**：定义抽奖的**主流程**与“接管”分支决策。  
**关键点**：

-   参数校验 → 取策略（里面带着规则配置）→ **把策略里的规则数组一起丢给 `doCheckRaffleBeforeLogic`**。
    
-   如果前置规则**接管**：
    
    -   黑名单：直接用规则结果里的 `awardId` 结束；
        
    -   权重：拿 `ruleWeightValueKey` 交给 `strategyDispatch.getRandomAwardId(strategyId, ruleWeightValueKey)` 在限定范围内抽。
        
    -   否则：走默认 `strategyDispatch.getRandomAwardId(strategyId)`。

# 先认识这三种设计模式（好懂速记版）

## 1) 工厂模式（Factory）

-   **是什么**：把“创建对象”的细节集中在一个地方，不让业务代码自己 `new`。像一个登记处/中转站，外部只管“按名字要东西”，不关心怎么造的。
    
-   **解决啥问题**：解耦“使用者”和“实例化细节”，新增一种实现时不用改到使用方。
    
-   **常见变体**：简单工厂、工厂方法、抽象工厂、**注册表工厂（registry）**。
    
-   **优点**：解耦创建、统一管理生命周期/缓存/装配；**对扩展友好**。
    
-   **注意**：别把“选择逻辑”写成一堆 `if-else`，更优是“用键（code）查表”。
    

## 2) 策略模式（Strategy）

-   **是什么**：把一类“可互换的算法/规则”用统一接口封装起来，**运行时**按条件选择其中一个来执行。
    
-   **解决啥问题**：避免“大而全的 if-else/switch 怪兽”，让每个规则独立、可替换、好测试。
    
-   **结构**：`Strategy` 接口 + 多个具体策略实现 + 负责**选择并调用**策略的“上下文”/编排器。
    
-   **优点**：开放封闭（加新策略不改老代码）、单一职责、可单测。
    
-   **注意**：别把“选择依据”散落一地；最好由配置或工厂统一分发。
    

## 3) 模板方法模式（Template Method）

-   **是什么**：**抽象父类**先把“流程骨架”写死（步骤顺序不可变），并把其中的某些步骤留作抽象/钩子，交给**子类去定制**。
    
-   **解决啥问题**：既保持流程统一、又允许各步骤差异化扩展。
    
-   **优点**：流程不跑偏，差异点可插拔；公共步骤可复用。
    
-   **注意**：别把父类写得太重；只抽象“稳定流程 + 变化点”。
    

----------

# 它们在你的抽奖流程里是怎么落地的？

## A. 工厂模式：`DefaultLogicFactory` = “规则实现的注册中心 + 分发器”

-   **做什么**：在启动时把所有带 `@LogicStrategy` 注解、且实现了 `ILogicFilter` 的规则实现**自动登记**到一个 `Map<规则code, 规则实现>`；对外提供 `openLogicFilter()` 让上层按 code 取到具体规则对象。  
    你可以看到它在构造函数里：遍历 Spring 注入的 `logicFilters` 列表，拿到每个类上的 `@LogicStrategy` 注解，把 `logicMode().getCode()` 作为 key 存进 `logicFilterMap`。  
    对外暴露的就是这行：`openLogicFilter()` 返回“code→规则”的映射。
    
-   **规则清单**：也在这个类里用枚举统一定义了**两个前置规则的 code**：`rule_weight`（权重范围）、`rule_blacklist`（黑名单）。这样“使用方”不会写错字符串。
    
-   **为什么是工厂**：业务侧**不直接 new 某个规则类**，而是“按 code 向工厂要实现”。这就是“创建与使用解耦”的典型工厂/注册表用法。
    

## B. 策略模式：`ILogicFilter` 接口 + 两个具体策略实现

-   **统一接口**：所有“前置规则”都实现同一个接口 `ILogicFilter`，对外暴露一个 `filter(RuleMatterEntity)` 方法；谁来执行、以谁为准，由编排器（后面说的 `DefaultRaffleStrategy`）决定。  
    在两个规则类上你能看到 `implements ILogicFilter<...>`：黑名单规则、权重规则。
    
-   **具体策略 1：黑名单**  
    命中黑名单就**接管**（返回 `TAKE_OVER`）并把“固定奖品ID”带回去；否则 `ALLOW` 放行。  
    该类通过 `@LogicStrategy(logicMode = RULE_BLACKLIST)` 把自己**注册**到工厂里，键就是 `rule_blacklist`。
    
-   **具体策略 2：权重**  
    解析规则值（如 `4000:102,103 5000:...`），按用户积分选中**一个可抽奖范围 key**，然后也用“接管”把这个 key 返回给上层；若解析不到或不命中，则 `ALLOW`。  
    同样用注解把自己注册为 `rule_weight`。
    
-   **为什么是策略**：这两个规则是“同一类问题（是否接管抽奖&如何限定范围）的不同算法实现”。它们**可互换**、**可并存**，新增规则也只需再写一个实现类 + 一个注解即可，老代码无需修改。
    

## C. 模板方法模式：`AbstractRaffleStrategy` 定义“抽奖总流程骨架”

-   **父类固定流程**：`performRaffle` 把“一次抽奖”的**大步骤**写死：
    
    1.  参数校验 → 2) 查策略 → 3) **调用一个抽象步骤 `doCheckRaffleBeforeLogic(...)` 做前置规则过滤** → 4) 根据过滤结果决定：黑名单直返奖品、权重在限定范围抽、否则默认抽。  
        这个“前置规则过滤”的**具体实现**，父类不关心，留给子类去写：`protected abstract RuleActionEntity... doCheckRaffleBeforeLogic(...)`。
        
-   **子类定制步骤**：`DefaultRaffleStrategy` 作为**子类**，覆盖了这个抽象方法，里面做了两件事：
    
    -   **黑名单优先**：如果配置里包含黑名单，就只跑黑名单并在“非 ALLOW”时**立刻返回**；
        
    -   **顺序跑剩余规则**：从工厂取到“code→规则实现”的 Map，按配置顺序挨个调用，遇到“非 ALLOW”就直接结束。
        
-   **为什么是模板方法**：抽奖的**流程顺序是稳定的**（父类模板）；而“前置规则如何编排”是**可变点**（子类去定制实现）。

# RuleBlackListLogicFilter 的“逐行”执行流程

当编排器调用到它的 `filter(...)` 方法时，流程是这样的：

1.  **拿到入参 + 打日志**  
    方法签名实现了统一接口 `ILogicFilter#filter`，先打出 `userId/strategyId/ruleModel` 方便排查。
    
2.  **向仓储查询这条规则的“配置值”**  
    通过 `repository.queryStrategyRuleValue(strategyId, awardId, ruleModel)` 取出黑名单的配置字符串（下文把它叫做 `ruleValue`）。
    
3.  **解析配置值**
    
    -   先按冒号切分：左边是“命中后要发的固定奖品ID”（如 `102`），右边是黑名单用户列表（如 `U1001,U1002`）；冒号与分隔符取自 `Constants.COLON / Constants.SPLIT`。
        
    -   把左半段 `awardId` 转成整数；把右半段继续按分隔符切成 `userBlackIds` 数组。
        
4.  **逐个比对是否命中当前用户**  
    只要发现 `userId` 出现在黑名单数组里，就**立即“接管”抽奖**并构造返回值：
    
    -   `ruleModel = "rule_blacklist"`（告诉上层是哪条规则接管的）；
        
    -   `data` 里放入 `strategyId` 和“要直接发放的 `awardId`”；
        
    -   `code = TAKE_OVER`（接管），`info` 同步写明接管。
        
5.  **未命中则放行**  
    如果整个黑名单都没匹配到当前用户，则返回 `ALLOW`，表示“我不接管，让后续规则/默认流程继续”。
    

> 直观例子：`ruleValue = "102:U1001,U2002"`，当前用户 `U1001`，则返回 `TAKE_OVER`，并把 `awardId=102` 放进返回体里；`U3003` 则返回 `ALLOW`。以上解析与判断都来自上面第 3～5 步。
<!--stackedit_data:
eyJoaXN0b3J5IjpbODIxNzAyMDgzLDE4MTg3NDcyNDQsOTc5Mj
I3NjgwLC0yMDg4NzQ2NjEyXX0=
-->