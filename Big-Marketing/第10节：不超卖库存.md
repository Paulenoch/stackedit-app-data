#### 第 1 步：活动初始化 - “把子弹装上膛” (库存预热)

在抽奖活动开始前，我们需要将奖品的库存数量从数据库加载到 Redis 缓存中。这样，后续的抽奖流程就可以直接和高速的 Redis 交互，而不是每次都去请求数据库。

-   **实现分析:**
    
    -   在 `Big-Market` 项目中，这个过程通常在活动上线或者系统启动时完成。会有一个后台任务或者一个初始化脚本，读取 `strategy_award` 表中的 `award_count`（奖品数量）字段。
        
    -   然后，将每个奖品的库存数量存入 Redis。这里通常会使用 `Hash` 或 `String` 数据结构。例如，使用一个`String`类型的键来存储库存：
        
        -   **Key:** `strategy_award_stock:{strategyId}:{awardId}` (策略ID:奖品ID)
            
        -   **Value:** `100` (初始库存数量)
            
    -   在你的代码 `paulenoch/big-market/Paulenoch-Big-Market-e623bc0a1d6c997def8c4288d3f256a4c01a9e18/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/armory/StrategyArmoryDispatch.java` 中 `assembleStrategyAward` 方法就是负责将策略奖品信息装配到缓存的过程，为后续抽奖做准备。
        

#### 第 2 步：用户抽奖 - “开枪前的最后一秒” (库存预扣减)

这是最核心的一步。当用户点击抽奖按钮时，程序会立即尝试在 Redis 中对相应奖品的库存进行扣减。

-   **实现分析:**
    
    -   当抽奖逻辑进行到库存校验环节时（例如在 `paulenoch/big-market/Paulenoch-Big-Market-e623bc0a1d6c997def8c4288d3f256a4c01a9e18/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/impl/RuleStockLogicTreeNode.java` 这个决策树节点中），它会执行库存扣减的逻辑。
        
    -   这个逻辑会调用仓储层的方法，如 `IStrategyRepository` 中的 `deductAwardStock` 方法。
        
    -   在仓储层的具体实现 `paulenoch/big-market/Paulenoch-Big-Market-e623bc0a1d6c997def8c4288d3f256a4c01a9e18/Big-Market-infrastructure/src/main/java/com/itheima/infrastructure/persistent/repository/StrategyRepository.java` 中，你会看到它调用了 Redis 的服务。
        
    -   关键操作是使用 Redis 的 `decr` 命令。这是一个**原子操作**。
        
        ```
        // 伪代码，演示核心逻辑
        String stockKey = "strategy_award_stock:" + strategyId + ":" + awardId;
        Long remainingStock = redisService.decr(stockKey); // 原子性地将库存减 1
        ```
        
    -   **判断扣减结果：**
        
        -   如果 `decr` 返回的结果大于等于 `0`，说明库存足够，预扣减成功！程序可以继续执行后续的中奖逻辑。
            
        -   如果 `decr` 返回的结果是负数（比如 `-1`），说明在你扣减之前，库存已经是 `0` 了。这意味着奖品已经发完，本次抽奖不能中这个奖品。程序应立即返回“库存不足”或将用户导向“未中奖”的结果。
            
    -   **为什么 `decr` 能保证原子性？** 因为 Redis 是单线程处理命令的，所有命令都会进入一个队列排队执行。即使一毫秒内有 10000 个请求同时到达，Redis 也会让它们一个一个地执行 `decr`，从而保证了计数的准确性，绝不会发生并发冲突。
        

#### 第 3 步：处理库存扣减失败 - “没子弹了，赶紧撤”

如果在第 2 步中，`decr` 操作返回了负数，说明库存已经耗尽。

-   **实现分析:**
    
    -   此时，程序需要将刚刚减掉的库存再加回去，以保证库存计数不会变成负数。这通过 Redis 的 `incr` 命令完成。
        
        ```
        // 伪代码
        if (remainingStock < 0) {
            // 库存不足，把刚才减掉的库存加回去
            redisService.incr(stockKey); 
            return "奖品已发完"; // 或者返回未中奖
        }
        ```
        
    -   在 `RuleStockLogicTreeNode` 的逻辑中，如果库存扣减失败，它会返回一个不允许的决策结果，从而引导抽奖流程走向“未中奖”或者尝试其他奖品（如果策略复杂的话）。
        

#### 第 4 步：数据持久化 - “清理战场，记录战果” (同步数据库)

Redis 中的库存成功扣减后，我们只是完成了“预扣减”。为了保证数据最终的可靠性，我们还需要更新数据库中的库存数量。

这一步通常是**异步**执行的，因为数据库操作相对较慢，如果同步执行会严重影响抽奖接口的性能。

-   **实现分析:**
    
    -   **方案一：使用消息队列 (MQ)**
        
        1.  在 Redis 库存扣减成功后，程序会发送一条消息到消息队列（如 RocketMQ、Kafka）。
            
        2.  消息内容包含：`strategyId`, `awardId` 等信息。
            
        3.  有一个专门的消费者服务来监听这个队列，收到消息后，执行数据库的 `UPDATE` 操作。
            
            ```
            UPDATE strategy_award SET award_count = award_count - 1 WHERE strategy_id = ? AND award_id = ? AND award_count > 0;
            ```
            
            这里 `AND award_count > 0` 是一个乐观锁，能进一步防止数据库层面的超卖。
            
    -   **方案二：定时任务**
        
        1.  在你的项目 `paulenoch/big-market/Paulenoch-Big-Market-e623bc0a1d6c997def8c4288d3f256a4c01a9e18/Big-Market-trigger/src/main/java/com/itheima/trigger/job/UpdateAwardStockJob.java` 中，就提供了一个定时任务的实现。
            
        2.  这个任务会定期（比如每分钟）扫描 Redis 中库存发生变化的奖品。
            
        3.  它会将 Redis 中的当前库存数量同步到数据库对应的 `strategy_award` 表中。这种方式虽然有一定延迟，但实现简单，对于很多场景也足够了。
            
    -   **方案三：更可靠的异步任务**
        
        1.  在扣减 Redis 库存后，可以将“待更新的数据库任务”记录到一个地方（比如 Redis 的另一个 List 或者数据库的某个任务表）。
            
        2.  然后由一个后台线程池异步地去执行这些更新任务。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE2MzM2NDg0Nl19
-->