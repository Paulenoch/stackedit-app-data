# 活动装配接口
第一步：活动装配activityArmory
-   **查询活动SKU列表**: 首先，通过 `activityRepository.queryActivitySkuListByActivityId` 从数据库中查询出该活动关联的所有 SKU (Stock Keeping Unit, 库存单位) 信息。每个 SKU 代表一种可参与的活动商品或资格。
    
-   **缓存SKU库存**: 遍历查询到的 SKU 列表，然后调用 `cacheActivitySkuStockCount` 方法。这个方法会将每个 SKU 的剩余库存数量 (`stockCountSurplus`) 存入 Redis 缓存。缓存的 Key 由一个固定的前缀 (`big_market_activity_sku_key_`) 和 SKU ID 拼接而成。
    
-   **预热活动次数**: 在循环中，还会调用 `activityRepository.queryRaffleActivityCountByActivityCountId`。这个方法会查询活动可参与的次数限制（总次数、每日次数、每月次数），并将查询结果缓存起来，供后续的抽奖资格校验使用。
    
-   **预热活动信息**: 最后，调用 `activityRepository.queryRaffleActivityByActivityId` 来查询活动的基本信息（如活动名称、描述、时间等），并将其缓存。


第二步：策略装配
-   **查询策略配置**: 方法首先通过 `repository.queryStrategyAwardList(strategyId)` 从数据库（或缓存）中获取该策略ID下配置的所有奖品列表 `strategyAwardEntities`。这个列表包含了每个奖品的ID、概率、剩余库存等信息。
    
-   **缓存奖品库存**: 遍历奖品列表，调用 `cacheStrategyAwardCount` 方法，将每个奖品的剩余库存数量 (`awardCountSurplus`) 存入 Redis。这是一个 `AtomicLong` 类型的原子计数器，用于后续抽奖时进行安全的库存扣减。
    
-   **默认装配 (全量抽奖概率)**: 调用 `assembleLotteryStrategy` 的重载方法，对**所有奖品**进行装配。这是默认的、最基础的抽奖池。我们稍后会深入讲解这个重载方法的内部实现。
    
-   **权重策略配置**:
    
    -   首先，查询策略实体 `StrategyEntity`，检查是否配置了权重规则 (`ruleWeight`)。
        
    -   如果配置了权重规则，会进一步查询具体的规则内容 `StrategyRuleEntity`。权重规则的格式通常是这样的：`4000:102,103,104,105 5000:102,103,104,105,106,107`，表示消费4000积分的用户可以抽奖品102-105，消费5000积分的用户可以抽奖品102-107。
        
    -   然后，代码会解析这个规则，并为**每一个权重等级**（如4000分、5000分）分别创建一个**专属的奖品池**。它会筛选出该权重等级对应的奖品，然后再次调用 `assembleLotteryStrategy` 的重载方法，为这个特定的权重等级生成一个独立的概率查找表。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE3OTk2OTMwNzksLTY1ODUwNDU3MiwtMT
Y3OTY3OTI4MSw0NDA5MDU2MTldfQ==
-->