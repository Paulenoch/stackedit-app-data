# 活动装配接口
## 第一步：活动装配activityArmory
-   **查询活动SKU列表**: 首先，通过 `activityRepository.queryActivitySkuListByActivityId` 从数据库中查询出该活动关联的所有 SKU (Stock Keeping Unit, 库存单位) 信息。每个 SKU 代表一种可参与的活动商品或资格。
    
-   **缓存SKU库存**: 遍历查询到的 SKU 列表，然后调用 `cacheActivitySkuStockCount` 方法。这个方法会将每个 SKU 的剩余库存数量 (`stockCountSurplus`) 存入 Redis 缓存。缓存的 Key 由一个固定的前缀 (`big_market_activity_sku_key_`) 和 SKU ID 拼接而成。
    
-   **预热活动次数**: 在循环中，还会调用 `activityRepository.queryRaffleActivityCountByActivityCountId`。这个方法会查询活动可参与的次数限制（总次数、每日次数、每月次数），并将查询结果缓存起来，供后续的抽奖资格校验使用。
    
-   **预热活动信息**: 最后，调用 `activityRepository.queryRaffleActivityByActivityId` 来查询活动的基本信息（如活动名称、描述、时间等），并将其缓存。


## 第二步：策略装配
-   **查询策略配置**: 方法首先通过 `repository.queryStrategyAwardList(strategyId)` 从数据库（或缓存）中获取该策略ID下配置的所有奖品列表 `strategyAwardEntities`。这个列表包含了每个奖品的ID、概率、剩余库存等信息。
    
-   **缓存奖品库存**: 遍历奖品列表，调用 `cacheStrategyAwardCount` 方法，将每个奖品的剩余库存数量 (`awardCountSurplus`) 存入 Redis。这是一个 `AtomicLong` 类型的原子计数器，用于后续抽奖时进行安全的库存扣减。
    
-   **默认装配 (全量抽奖概率)**: 调用 `assembleLotteryStrategy` 的重载方法，对**所有奖品**进行装配。这是默认的、最基础的抽奖池。我们稍后会深入讲解这个重载方法的内部实现。
    
-   **权重策略配置**:
    
    -   首先，查询策略实体 `StrategyEntity`，检查是否配置了权重规则 (`ruleWeight`)。
        
    -   如果配置了权重规则，会进一步查询具体的规则内容 `StrategyRuleEntity`。权重规则的格式通常是这样的：`4000:102,103,104,105 5000:102,103,104,105,106,107`，表示消费4000积分的用户可以抽奖品102-105，消费5000积分的用户可以抽奖品102-107。
        
    -   然后，代码会解析这个规则，并为**每一个权重等级**（如4000分、5000分）分别创建一个**专属的奖品池**。它会筛选出该权重等级对应的奖品，然后再次调用 `assembleLotteryStrategy` 的重载方法，为这个特定的权重等级生成一个独立的概率查找表。

**算法讲解:**

这个算法的核心思想是将**概率**转换成一个**整数范围**，然后在这个范围内进行随机取值，从而实现概率抽奖。

1.  **获取最小概率值**: 找出所有奖品中最小的中奖概率。例如，有三个奖品，概率分别是 0.1, 0.02, 0.003，那么最小概率就是 0.003。
    
2.  **计算概率范围值 (`rateRange`)**: 根据最小概率值，计算出一个整数范围。这个范围的计算方法是：找到一个10的幂，使得最小概率乘以这个幂之后，结果大于等于1。
    
    -   例如，最小概率是 0.1，乘以10后是1，所以 `rateRange` 是 10。
        
    -   最小概率是 0.02，乘以100后是2，所以 `rateRange` 是 100。
        
    -   最小概率是 0.003，乘以1000后是3，所以 `rateRange` 是 1000。 这个 `rateRange` 决定了我们抽奖时随机数的最大值。
        
3.  **生成概率查找表**: 创建一个列表 `strategyAwardSearchRateTables`，然后根据每个奖品的概率和 `rateRange`，向列表中填充相应数量的奖品 ID。
    
    -   假设 `rateRange` 是 1000，某个奖品的概率是 0.1，那么就在列表中添加 `1000 * 0.1 = 100` 个该奖品的 ID。
        
    -   另一个奖品概率是 0.02，就添加 `1000 * 0.02 = 20` 个该奖品的 ID。 这样，列表中奖品ID的数量就和它的中奖概率成正比了。
        
4.  **乱序操作**: 使用 `Collections.shuffle` 将列表中的奖品 ID 完全打乱。这是为了保证抽奖的随机性。
    
5.  **生成Map集合**: 将乱序后的列表转换成一个 Map，Key 是从 0 到 `rateRange-1` 的整数，Value 是对应的奖品 ID。
    
6.  **存入Redis**: 最后，将这个 Map 存入 Redis，作为最终的概率查找表。同时，也会将 `rateRange` 的值存入 Redis，以便后续抽奖时使用。
    

#### **总结**

`assembleLotteryStrategy` 方法通过一系列精巧的设计，将复杂的抽奖逻辑预处理成一个简单高效的查找表。这种“空间换时间”的策略，使得在用户进行抽奖时，只需要生成一个随机数，然后在 Redis 中进行一次 O(1) 复杂度的查找，就能快速确定中奖结果，极大地提升了系统的性能和并发处理能力。


# 抽奖接口
#### **2. 创建抽奖资格订单 (`createOrder`)**

在正式抽奖前，系统需要确认用户有资格参与本次抽奖，并通过创建一个唯一的“抽奖单”来记录这次行为。这个关键步骤由 `raffleActivityPartakeService.createOrder` 完成。

Java

```
// 2. 参与活动 - 创建参与记录订单
UserRaffleOrderEntity orderEntity = raffleActivityPartakeService.createOrder(request.getUserId(), request.getActivityId());
log.info("活动抽奖，创建订单 userId:{} activityId:{} orderId:{}", request.getUserId(), request.getActivityId(), orderEntity.getOrderId());
```

**代码讲解:**

这个 `createOrder` 方法是抽奖资格的核心校验和凭证生成环节，其具体逻辑在 `AbstractRaffleActivityPartake` 抽象类和其实现类 `RaffleActivityPartakeService` 中。

1.  **活动状态与日期校验**:
    
    -   首先查询活动信息 `ActivityEntity`。
        
    -   检查活动状态是否为 `open`（开启）。
        
    -   检查当前时间是否在活动的 `beginDateTime` 和 `endDateTime` 之间。
        
    -   任何一项不满足，则直接抛出异常，阻止抽奖。
        
2.  **幂等性检查**:
    
    -   查询该用户在该活动下是否有状态为 `create`（已创建但未使用）的抽奖单 `UserRaffleOrderEntity`。
        
    -   如果存在，说明用户可能因为网络问题重复点击了抽奖按钮。此时系统不会创建新的抽奖单，而是直接返回之前创建的订单，保证一次抽奖行为只对应一个订单。
        
3.  **账户额度过滤 (`doFilterAccount`)**:
    
    -   这是最核心的资格校验环节，在一个方法内，通过事务性的方式，对用户的总、月、日三个维度的抽奖次数进行检查和扣减。
        
    -   **查询**：依次查询总账户 (`raffle_activity_account`)、月账户 (`raffle_activity_account_month`)、日账户 (`raffle_activity_account_day`) 的剩余次数。
        
    -   **判断**：如果任一账户的剩余次数小于等于0，则抛出对应的异常（如：`ACCOUNT_QUOTA_ERROR`, `ACCOUNT_MONTH_QUOTA_ERROR`），流程终止。
        
    -   **扣减**：如果所有校验都通过，会在后续的数据库事务中，对这三个表的剩余次数进行 `-1` 操作。
        
4.  **构建并保存订单**:
    
    -   调用 `buildUserRaffleOrder` 方法，生成一个唯一的订单ID (`orderId`)，并组装成 `UserRaffleOrderEntity` 对象。
        
    -   将上述所有需要变更的数据（账户扣减信息、新生成的订单）封装进一个聚合对象 `CreatePartakeOrderAggregate`。
        
    -   调用 `activityRepository.saveCreatePartakeOrderAggregate`，在一个数据库事务内，完成对总、月、日账户表的更新，以及新抽奖订单的插入操作。这保证了“资格校验”和“凭证生成”的原子性。

`saveCreatePartakeOrderAggregate`
**代码讲解:**

1.  **数据库路由 (`dbRouter`)**:
    
    -   在进入事务之前，代码首先调用了 `dbRouter.doRouter(userId)`。
        
    -   **作用**: 这是一个分库分表中间件的调用。它会根据 `userId` 计算出一个哈希值，决定接下来所有的数据库操作应该路由到哪个具体的数据库实例和表中。例如，`userId`为偶数的用户数据存放在`db_01`，奇数用户存放在`db_02`。
        
    -   **重要性**: 确保了与该用户相关的所有数据（总、月、日账户，以及订单）都落在同一个库中，这是实现事务的前提。
        
    -   `finally` 块中的 `dbRouter.clear()` 负责在操作结束后清理路由信息，避免影响其他线程。
        
2.  **编程式事务 (`transactionTemplate`)**:
    
    -   项目没有使用更常见的 `@Transactional` 注解，而是使用了 `TransactionTemplate` 编程式事务。
        
    -   **原因**: 编程式事务可以更精细地控制事务的边界，并且可以方便地在事务中进行手动回滚 (`status.setRollbackOnly()`)。在这里，当检查到库存扣减失败时，可以立即标记事务为回滚状态并抛出异常。
        
3.  **原子操作详解（事务内部）**:
    
    -   **第一步：更新总账户**
        
        -   调用 `raffleActivityAccountDao.updateActivityAccountSubtractionQuota`，对 `raffle_activity_account` 表执行 `UPDATE` 操作。
            
        -   SQL语句的核心是 `set total_count_surplus = total_count_surplus - 1 where ... and total_count_surplus > 0`。这是一个**乐观锁**的实现，`total_count_surplus > 0` 保证了不会超扣。
            
        -   方法会返回受影响的行数。如果行数不为1，说明库存不足或用户不存在，此时会手动回滚事务并抛出异常。
            
    -   **第二步：更新/创建月账户**
        
        -   `isExistAccountMonth` 标志位是在之前的 `doFilterAccount` 步骤中设置的。
            
        -   **更新**: 如果月账户已存在，则调用 `updateActivityAccountMonthSubtractionQuota` 扣减月剩余次数，同样使用乐观锁 (`month_count_surplus > 0`)。
            
        -   **创建**: 如果是本月第一次抽奖，则调用 `insertActivityAccountMonth`，插入一条新的月账户记录，并将剩余次数设置为 `总次数 - 1`。
            
    -   **第三步：更新/创建日账户**
        
        -   逻辑与月账户完全相同，只是操作的表是 `raffle_activity_account_day`。
            
    -   **第四步：写入抽奖订单**
        
        -   最后，调用 `userRaffleOrderDao.insert`，将新生成的 `UserRaffleOrder` 写入数据库，状态为 `create`。
            
4.  **异常处理**:
    
    -   通过 `try-catch` 捕获 `DuplicateKeyException`。这通常发生在 `user_raffle_order` 表的 `order_id` 出现重复时（尽管概率极低），此时会回滚事务，保证数据不会被污染。

#### **3. 执行核心抽奖策略 (`performRaffle`)**

获取到合法的抽奖订单后，就进入了真正的抽奖计算环节。

Java

```
// 3. 抽奖策略 - 执行抽奖
RaffleAwardEntity raffleAwardEntity = raffleStrategy.performRaffle(RaffleFactorEntity.builder()
        .userId(orderEntity.getUserId())
        .strategyId(orderEntity.getStrategyId())
        .endDateTime(orderEntity.getEndDateTime())
        .build());
```

**代码讲解:**

`performRaffle` 方法是抽奖策略的入口，它定义在 `AbstractRaffleStrategy` 抽象类中，是整个抽奖逻辑的核心调度者。它通过**责任链模式**和**规则树引擎**，分阶段、分层次地完成复杂的抽奖计算。

-   **阶段一：责任链过滤 (`raffleLogicChain`)**
    
    -   **目的**：进行前置规则的过滤，快速筛选掉不符合特定规则的用户，或者为符合特定规则的用户直接指定奖品。
        
    -   **流程**：
        
        1.  **黑名单规则 (`rule_blacklist`)**: 检查用户是否在黑名单中。如果是，则直接返回预设的兜底奖品（如1积分），并中断后续流程。
            
        2.  **权重规则 (`rule_weight`)**: 根据用户的积分或等级，判断用户是否能进入更高权重的奖品池。如果满足条件，则从对应的权重奖品池中进行抽奖。
            
        3.  **默认规则 (`rule_default`)**: 如果以上规则都未命中，则进入默认流程。此时，会从 Redis 中获取预先装配好的**全量概率查找表**，生成一个随机数，直接从查找表中取出对应的奖品ID。
            
-   **阶段二：规则树过滤 (`raffleLogicTree`)**
    
    -   **目的**：对责任链返回的初步奖品ID进行后置的、更复杂的条件校验。
        
    -   **流程**：
        
        1.  **次数锁规则 (`rule_lock`)**: 检查该奖品是否有解锁条件，比如需要用户抽奖N次后才能获得。如果用户抽奖次数未达到要求，则该奖品被“拦截”，流程会走向兜底方案。
            
        2.  **库存扣减规则 (`rule_stock`)**: 这是最关键的一步。系统会尝试对该奖品在 Redis 中的库存执行 `decr`（原子减1）操作。
            
            -   **成功**: 如果 `decr` 后的值大于等于0，说明库存扣减成功，该奖品被确认为最终中奖奖品。同时，会发送一条延迟消息到队列，用于后续异步更新数据库库存。
                
            -   **失败**: 如果 `decr` 后的值为负数，说明在并发环境下，这个奖品已经被抽完。此时，流程会走向下一个节点。
                
        3.  **兜底奖励规则 (`rule_luck_award`)**: 如果前面的规则（如次数锁、库存不足）导致无法获得原定奖品，流程会进入这个节点，返回一个预设的“幸运奖”或“安慰奖”，确保用户总能获得一个结果。
            


责任链负责**抽奖前的资格过滤和分流**，而规则树则负责**抽中奖品后的逻辑校验和结果修正**。

### **一、 责任链模式：抽奖资格的层层过滤**

责任链模式在这里的作用，就像是一条流水线上的多个安检口。用户的抽奖请求会依次通过这些安检口，每个安检口负责一项特定的检查。如果某个安检口发现问题（例如用户在黑名单里），它就会直接“接管”请求并给出最终结果；如果没问题，则“放行”给下一个安检口。

#### **1. 核心组件**

-   **抽象链节点 (`ILogicChain` & `AbstractLogicChain`)**:
    
    -   `ILogicChain` 接口定义了责任链节点的核心行为：`logic` 方法用于执行当前节点的逻辑，`next` 和 `appendNext` 用于构建链条。
        
    -   `AbstractLogicChain` 是一个抽象类，实现了链的连接逻辑，让具体的规则节点只需关注自己的业务逻辑。
        
-   **具体规则节点 (Handler)**:
    
    -   **`BlackListLogicChain` (黑名单规则)**: 检查用户ID是否存在于配置的黑名单中。如果存在，它会直接**接管**请求，返回一个预设的兜底奖品ID，并终止责任链的继续传递。
        
    -   **`RuleWeightLogicChain` (权重规则)**: 根据用户的积分或等级 (`userScore`)，判断用户是否满足进入特定权重奖品池的条件。如果满足，它会**接管**请求，并调用 `strategyDispatch.getRandomAwardId` 在**指定的奖品范围**内进行抽奖。
        
    -   **`DefaultLogicChain` (默认规则)**: 这是责任链的**最后一个节点**。如果前面的所有规则都“放行”了，请求最终会到达这里。它会调用 `strategyDispatch.getRandomAwardId` 在**全量奖品池**中进行标准的随机抽奖。
        

#### **2. 责任链的动态构建 (`DefaultChainFactory`)**

这个项目最巧妙的设计之一就是责任链的**动态构建**。运营人员可以在数据库中配置策略的 `rule_models` 字段（例如配置为 `rule_blacklist,rule_weight`），系统会根据这个配置顺序来自动组装责任链。

Java

```
// DefaultChainFactory.java
public ILogicChain openLogicChain(Long strategyId) {
    StrategyEntity strategy = repository.queryStrategyEntityByStrategyId(strategyId);
    String[] ruleModels = strategy.ruleModels();

    // 如果未配置策略规则，则只装填一个默认责任链
    if (null == ruleModels || 0 == ruleModels.length) return logicChainGroup.get(LogicModel.RULE_DEFAULT.getCode());

    // 按照配置顺序装填用户配置的责任链
    ILogicChain logicChain = logicChainGroup.get(ruleModels[0]);
    ILogicChain current = logicChain;
    for (int i = 1; i < ruleModels.length; i++) {
        ILogicChain nextChain = logicChainGroup.get(ruleModels[i]);
        current = current.appendNext(nextChain);
    }

    // 责任链的最后装填默认责任链
    current.appendNext(logicChainGroup.get(LogicModel.RULE_DEFAULT.getCode()));

    return logicChain;
}
```

**代码讲解:**

1.  **获取规则模型**: 首先根据 `strategyId` 从数据库（或缓存）中查询出 `rule_models` 字符串。
    
2.  **动态注入**: Spring会将所有实现了 `ILogicChain` 接口的 Bean（`BlackListLogicChain`、`RuleWeightLogicChain` 等）自动注入到 `logicChainGroup` 这个 `Map` 中，Key 就是它们的 Bean 名称（如 `"rule_blacklist"`, `"rule_weight"`）。
    
3.  **循环组装**: 代码会遍历 `ruleModels` 数组，从 `logicChainGroup` 中取出对应的 Bean，并使用 `appendNext` 方法像链表一样将它们串联起来。
    
4.  **默认兜底**: 无论用户如何配置，`DefaultLogicChain` 总是会被自动追加到链条的末尾，确保了总会有一个抽奖逻辑被执行。
    

### **二、 规则树模式：抽奖结果的复杂决策**

当责任链初步确定了一个奖品ID后，并不意味着用户就能最终得到这个奖品。比如，奖品可能库存不足，或者需要满足特定条件才能解锁。这时，就需要规则树来进行更复杂的、非线性的逻辑判断。

#### **1. 核心组件**

-   **规则树定义 (`RuleTreeVO`, `RuleTreeNodeVO`, `RuleTreeNodeLineVO`)**:
    
    -   `RuleTreeVO`: 代表一整棵决策树，包含了树的ID、名称、根节点以及所有节点的集合 `treeNodeMap`。
        
    -   `RuleTreeNodeVO`: 代表树中的一个节点，包含了节点的 `ruleKey`（如`rule_stock`），`ruleValue`（规则所需的具体值，如库存扣减成功后的兜底奖品ID）以及指向其他节点的“线” `treeNodeLineVOList`。
        
    -   `RuleTreeNodeLineVO`: 代表节点之间的一条连接线，定义了从哪个节点 (`ruleNodeFrom`) 到哪个节点 (`ruleNodeTo`)，以及触发这条线的条件（`ruleLimitType` 和 `ruleLimitValue`）。
        
-   **规则树节点逻辑 (`ILogicTreeNode`)**:
    
    -   这是一个接口，定义了所有规则节点的行为：`logic` 方法。每个实现类都代表一种具体的业务判断。
        
    -   **`RuleLockLogicTreeNode` (次数锁)**: 判断用户的抽奖次数是否达到了 `ruleValue` 中设定的阈值。如果未达到，返回 `TAKE_OVER`（接管），流程将转向兜底奖品；如果达到，返回 `ALLOW`（放行），流程继续。
        
    -   **`RuleStockLogicTreeNode` (库存扣减)**: 尝试对奖品库存进行原子扣减。如果成功，返回 `TAKE_OVER` 并附带中奖信息；如果失败（库存不足），返回 `ALLOW`，流程将转向兜底奖品。
        
    -   **`RuleLuckAwardLogicTreeNode` (兜底奖品)**: 这是一个终结节点。一旦流程进入这里，它会直接返回 `ruleValue` 中配置的兜底奖品ID，确保用户总能得到一个结果。
        

#### **2. 规则树的执行引擎 (`DecisionTreeEngine`)**

规则树的执行由 `DecisionTreeEngine` 负责，它像一个解释器，负责遍历和执行规则树的逻辑。

Java

```
// DecisionTreeEngine.java
public DefaultTreeFactory.StrategyAwardVO process(String userId, Long strategyId, Integer awardId, Date endDateTime) {
    DefaultTreeFactory.StrategyAwardVO strategyAwardData = null;

    // 获取基础信息
    String nextNode = ruleTreeVO.getTreeRootRuleNode();
    Map<String, RuleTreeNodeVO> treeNodeMap = ruleTreeVO.getTreeNodeMap();

    // 获取起始节点
    RuleTreeNodeVO ruleTreeNode = treeNodeMap.get(nextNode);
    while (null != nextNode) {
        // 获取决策节点
        ILogicTreeNode logicTreeNode = logicTreeNodeGroup.get(ruleTreeNode.getRuleKey());

        // 决策节点计算
        DefaultTreeFactory.TreeActionEntity logicEntity = logicTreeNode.logic(...);
        RuleLogicCheckTypeVO ruleLogicCheckTypeVO = logicEntity.getRuleLogicCheckType();
        strategyAwardData = logicEntity.getStrategyAwardVO();

        // 获取下个节点
        nextNode = nextNode(ruleLogicCheckTypeVO.getCode(), ruleTreeNode.getTreeNodeLineVOList());
        ruleTreeNode = treeNodeMap.get(nextNode);
    }
    return strategyAwardData;
}
```

**代码讲解:**

1.  **获取根节点**: 从 `RuleTreeVO` 中获取根节点的 `ruleKey` (`treeRootRuleNode`)。
    
2.  **循环执行**: 进入一个 `while` 循环，只要 `nextNode` 不为空，就持续执行。
    
3.  **执行节点逻辑**: 在循环中，根据 `nextNode` 的 `ruleKey` 从 `logicTreeNodeGroup` 中找到对应的逻辑实现类（如`RuleStockLogicTreeNode`），并执行其 `logic` 方法。
    
4.  **获取决策结果**: `logic` 方法会返回一个 `TreeActionEntity`，其中包含了最重要的决策结果 `RuleLogicCheckTypeVO`（`ALLOW` 或 `TAKE_OVER`）。
    
5.  **寻找下一个节点 (`nextNode`方法)**: 引擎会遍历当前节点的所有“连接线” (`treeNodeLineVOList`)，寻找与 `logic` 方法返回的决策结果相匹配的线。例如，如果 `logic` 返回 `ALLOW`，它就会找到 `ruleLimitValue` 为 `ALLOW` 的那条线，并取出它的 `ruleNodeTo` 作为下一个要执行的节点。
    
6.  **循环继续**: `while` 循环继续，直到 `nextNode` 为 `null`（意味着到达了叶子节点或没有匹配的路径），循环结束。
    
7.  **返回结果**: 返回最后一次 `logic` 方法执行后得到的 `strategyAwardData`。
    

### **总结：责任链与规则树的协同工作**

-   **分工明确**：责任链负责**“前置过滤”**，处理的是线性的、一票否决式的规则。它的逻辑相对简单，执行速度快。
    
-   **能力互补**：规则树负责**“后置决策”**，处理的是复杂的、有分支的、需要根据不同情况走向不同流程的规则。
    
-   **协同流程**：
    
    1.  用户的抽奖请求首先进入**责任链**。
        
    2.  责任链经过层层过滤，得出一个初步的**奖品ID**。
        
    3.  这个奖品ID被传递给**规则树**。
        
    4.  规则树根据这个奖品ID，结合用户的其他信息（如抽奖次数），执行库存、解锁条件等一系列复杂的判断，最终给出**修正后**的、真正应该发放给用户的奖品ID。


#### **4. 记录中奖结果 (`saveUserAwardRecord`)**

抽奖策略执行完毕后，系统拿到了最终的中奖结果 `RaffleAwardEntity`。接下来，需要将这个结果持久化。

Java

```
// 4. 存放结果 - 写入中奖记录
UserAwardRecordEntity userAwardRecord = UserAwardRecordEntity.builder()
        // ... 组装中奖记录信息
        .build();
awardService.saveUserAwardRecord(userAwardRecord);
```
**代码讲解:**

这一步的核心是调用 `awardService.saveUserAwardRecord`。

-   **聚合封装**: 将中奖信息 `UserAwardRecordEntity` 和一个用于发送MQ消息的 `TaskEntity` 封装成一个 `UserAwardRecordAggregate` 聚合对象。
    
-   **事务保存**: 在一个数据库事务中，完成三件事：
    
    1.  向 `user_award_record` 表插入中奖记录。
        
    2.  向 `task` 表插入一条待发送的MQ消息任务。
        
    3.  更新 `user_raffle_order` 表，将之前创建的抽奖单状态从 `create` 更新为 `used`，防止重复使用。
        
-   **发送MQ消息**: 事务成功后，将 `Task` 表中的消息内容发送到 RabbitMQ。后续的发奖流程将由监听该MQ消息的消费者来异步处理，实现了抽奖与发奖的解耦

**代码讲解:**

1.  **聚合封装 (`UserAwardRecordAggregate`)**
    
    -   在进入仓储层之前，`AwardService` 会将 `UserAwardRecordEntity`（中奖记录）和一个新创建的 `TaskEntity`（消息任务）封装成一个 `UserAwardRecordAggregate` 聚合对象。
        
    -   这个聚合的意义在于，**“记录中奖”**和**“创建发奖通知任务”**是两个业务上必须同时成功的操作，它们共同构成了一个完整的业务单元。
        
2.  **事务性数据库操作**
    
    -   和我们之前分析的 `saveCreatePartakeOrderAggregate` 一样，这里也使用了 `dbRouter` 进行分库路由，并用 `transactionTemplate` 开启了一个编程式事务，以保证操作的原子性。
        
    -   在事务内部，执行了三个关键的数据库操作：
        
        -   **写入中奖记录**: 调用 `userAwardRecordDao.insert`，将中奖信息（用户ID、活动ID、奖品ID、订单ID等）插入到 `user_award_record` 表中。
            
        -   **写入消息任务**: 调用 `taskDao.insert`，将发奖消息（包含了奖品信息）作为一个任务存入 `task` 表，初始状态为 `create`（创建）。
            
        -   **更新抽奖单状态**: 调用 `userRaffleOrderDao.updateUserRaffleOrderStateUsed`，将 `user_raffle_order` 表中对应的抽奖单状态从 `create` 更新为 `used`。
            
            -   **关键校验**: 这里的 `UPDATE` 语句同样带有一个 `WHERE ... AND order_state = 'create'` 的条件。这是一个**非常重要的幂等性校验**。它能防止同一个抽奖订单被重复用于记录中奖。如果 `update` 返回的行数不为1，说明这个订单已经被使用过了，事务会立即回滚，并抛出 `ACTIVITY_ORDER_ERROR` 异常。
                
3.  **异步消息发送 (事务外)**
    
    -   **为什么在事务外？**: 消息发送是一个网络I/O操作，可能会因为网络抖动而耗时较长或失败。如果将其放在数据库事务内，会长时间占用数据库连接，降低系统吞吐量。更严重的是，如果消息发送失败，可能会导致整个数据库事务回滚，这并非我们所期望的（因为中奖记录本身已经成功了）。
        
    -   **解耦实现**:
        
        -   在数据库事务成功提交后，调用 `eventPublisher.publish` 将 `Task` 中的消息内容发送到 RabbitMQ。
            
        -   发送成功后，立即调用 `taskDao.updateTaskSendMessageCompleted` 将 `task` 表中的对应记录状态更新为 `completed`。
            
    -   **可靠性保障（补偿机制）**:
        
        -   如果在 `publish` 步骤因为网络问题等原因失败了，`catch` 块会被执行。
            
        -   `catch` 块会调用 `taskDao.updateTaskSendMessageFail` 将任务状态更新为 `fail`。
            
        -   后台会有一个定时任务 (`SendMessageTaskJob`)，它会定期扫描 `task` 表中所有状态为 `fail` 或长时间处于 `create` 状态的任务，并重新尝试发送，这就是**最终一致性**的保障机制。


### **一、 RabbitMQ：业务流程的解耦与可靠通知**

项目中使用 RabbitMQ 来处理那些不需要实时同步返回结果，但又必须可靠执行的后续业务流程。这主要体现在两个场景：

1.  **异步发送发奖通知**
    
2.  **库存清零的广播通知**
    

#### **场景1：异步发送发奖通知 (send_award)**

这是消息队列最核心的应用场景。当用户抽奖成功后，主流程需要快速地返回中奖结果给用户，而后续的发奖操作（如调用第三方接口发放积分、卡券等）可能比较耗时或依赖外部服务。将发奖操作异步化是最佳选择。

-   **消息生产者 (Producer)**:
    
    -   **触发点**: `AwardRepository` 的 `saveUserAwardRecord` 方法。
        
    -   **流程**:
        
        1.  在一个数据库事务中，首先将中奖记录写入 `user_award_record` 表，同时将要发送的消息内容写入 `task` 任务表，状态为“创建”。
            
        2.  数据库事务成功提交后，在事务外部，调用 `eventPublisher.publish` 方法将消息发送到 RabbitMQ 的 `send_award` 主题。
            
    -   **消息体 (`SendAwardMessageEvent`)**: 消息内容被封装在 `SendAwardMessage` 对象中，包含了 `userId`、`awardId` 和 `awardTitle` 等发奖所需的核心信息。
        
-   **消息消费者 (Consumer)**:
    
    -   **监听器**: `SendAwardCustomer` 类中的 `listener` 方法。
        
    -   **注解**: `@RabbitListener(queuesToDeclare = @Queue(value = "${spring.rabbitmq.topic.send_award}"))` 声明了该方法监听 `send_award` 队列。
        
    -   **职责**: 监听到消息后，可以在这里编写具体的发奖逻辑，例如调用积分服务接口、卡券服务接口等。在当前项目中，为了简化，只是打印了日志。
        
-   **可靠性保障 (补偿机制)**:
    
    -   **问题**: 如果在发送MQ消息时（`eventPublisher.publish`）发生网络故障，消息可能会发送失败。
        
    -   **解决方案**: `task` 表和 `SendMessageTaskJob` 定时任务。
        
        1.  如果 `publish` 成功，`task` 表中对应的任务状态会被更新为 `completed`。
            
        2.  如果 `publish` 失败，任务状态会被更新为 `fail`。
            
        3.  `SendMessageTaskJob` 定时任务会每隔5秒扫描所有分库的 `task` 表，找出状态为 `fail` 或长时间处于 `create` 状态的任务，并重新尝试发送。这确保了消息**最终一定能被成功发送**，实现了**最终一致性**。
            

#### **场景2：活动SKU库存清零通知 (activity_sku_stock_zero)**

当某个活动的参与资格（SKU）库存被消耗完毕时，需要通知系统进行一些后续处理。

-   **消息生产者 (Producer)**:
    
    -   **触发点**: `ActivityRepository` 的 `subtractionActivitySkuStock` 方法。
        
    -   **流程**: 当 Redis 中的 SKU 库存在 `decr`（原子减1）后，返回值恰好为 `0` 时，说明这是最后一个库存。此时，通过 `eventPublisher.publish` 发送一条消息到 `activity_sku_stock_zero` 主题。
        
    -   **消息体 (`ActivitySkuStockZeroMessageEvent`)**: 消息内容就是被消耗完的 `sku` 的ID。
        
-   **消息消费者 (Consumer)**:
    
    -   **监听器**: `ActivitySkuStockZeroCustomer` 类中的 `listener` 方法。
        
    -   **职责**:
        
        1.  调用 `skuStock.clearActivitySkuStock(sku)`，将数据库中 `raffle_activity_sku` 表对应的库存 `stock_count_surplus` 字段更新为0。
            
        2.  调用 `skuStock.clearQueueValue()`，清空用于延迟更新数据库的 Redisson 队列。因为库存已经明确为0了，不再需要后续的延迟任务去逐个更新。
            

### **二、 Redisson 延迟队列：数据库流量削峰**

在高并发场景下，如果每次抽奖都直接更新数据库的库存，会给数据库带来巨大的瞬时压力。项目采用了一种非常经典的优化方案：**缓存扣减 + 异步批量更新**。

-   **生产者 (Producer)**:
    
    -   **触发点**: 规则树节点 `RuleStockLogicTreeNode` 和责任链节点 `ActivitySkuStockActionChain`。
        
    -   **流程**: 当 Redis 中的奖品库存或SKU库存扣减成功后，并**不是立即去更新数据库**。而是调用 `strategyRepository.awardStockConsumeSendQueue` 或 `activityRepository.activitySkuStockConsumeSendQueue` 方法。
        
    -   **实现**: 这两个方法内部，都是将需要更新库存的 `strategyId` 和 `awardId`（或 `sku` 和 `activityId`）封装成一个 `KeyVO` 对象，然后通过 `delayedQueue.offer(..., 3, TimeUnit.SECONDS)` 将其放入一个 Redisson 的**延迟队列**中。这意味着，这条消息在3秒后才真正变得“可消费”。
        
-   **消费者 (Consumer)**:
    
    -   **定时任务**: `UpdateAwardStockJob` 和 `UpdateActivitySkuStockJob`。
        
    -   **流程**: 这两个定时任务每5秒执行一次。
        
        1.  它们会尝试从各自的 Redisson 队列中 `takeQueueValue()`。由于是延迟队列，它们只能取到已经“到期”的消息。
            
        2.  取到消息后，再调用 `updateStrategyAwardStock` 或 `updateActivitySkuStock` 方法去执行数据库的 `UPDATE ... SET stock_count_surplus = stock_count_surplus - 1` 操作。
            
-   **优势 (流量削峰)**:
    
    -   假设在1秒内有1000次抽奖请求，库存都在 Redis 中实时扣减，保证了业务的正确性。
        
    -   但最终对数据库的 `UPDATE` 操作，被分散到了后续的时间里，由定时任务以每5秒一次的频率，平滑地、逐个地去执行。
        
    -   这极大地降低了数据库在活动高峰期的写入压力，将集中的流量“削平”成平缓的流量，是提升系统整体性能和稳定性的关键手段。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTMyNjc3Njg5OSwtMjAwNTU5NDM2Nyw0OD
YxMTExNjksLTE5MTgzMzU2NDMsLTE1NTk5ODYzNjksLTIwMTMy
MDk1NjUsMTQ3NDgyNzIzNywtMTc5OTY5MzA3OSwtNjU4NTA0NT
cyLC0xNjc5Njc5MjgxLDQ0MDkwNTYxOV19
-->