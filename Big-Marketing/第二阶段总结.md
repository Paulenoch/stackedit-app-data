# 活动装配接口
## 第一步：活动装配activityArmory
-   **查询活动SKU列表**: 首先，通过 `activityRepository.queryActivitySkuListByActivityId` 从数据库中查询出该活动关联的所有 SKU (Stock Keeping Unit, 库存单位) 信息。每个 SKU 代表一种可参与的活动商品或资格。
    
-   **缓存SKU库存**: 遍历查询到的 SKU 列表，然后调用 `cacheActivitySkuStockCount` 方法。这个方法会将每个 SKU 的剩余库存数量 (`stockCountSurplus`) 存入 Redis 缓存。缓存的 Key 由一个固定的前缀 (`big_market_activity_sku_key_`) 和 SKU ID 拼接而成。
    
-   **预热活动次数**: 在循环中，还会调用 `activityRepository.queryRaffleActivityCountByActivityCountId`。这个方法会查询活动可参与的次数限制（总次数、每日次数、每月次数），并将查询结果缓存起来，供后续的抽奖资格校验使用。
    
-   **预热活动信息**: 最后，调用 `activityRepository.queryRaffleActivityByActivityId` 来查询活动的基本信息（如活动名称、描述、时间等），并将其缓存。


## 第二步：策略装配
-   **查询策略配置**: 方法首先通过 `repository.queryStrategyAwardList(strategyId)` 从数据库（或缓存）中获取该策略ID下配置的所有奖品列表 `strategyAwardEntities`。这个列表包含了每个奖品的ID、概率、剩余库存等信息。
    
-   **缓存奖品库存**: 遍历奖品列表，调用 `cacheStrategyAwardCount` 方法，将每个奖品的剩余库存数量 (`awardCountSurplus`) 存入 Redis。这是一个 `AtomicLong` 类型的原子计数器，用于后续抽奖时进行安全的库存扣减。
    
-   **默认装配 (全量抽奖概率)**: 调用 `assembleLotteryStrategy` 的重载方法，对**所有奖品**进行装配。这是默认的、最基础的抽奖池。我们稍后会深入讲解这个重载方法的内部实现。
    
-   **权重策略配置**:
    
    -   首先，查询策略实体 `StrategyEntity`，检查是否配置了权重规则 (`ruleWeight`)。
        
    -   如果配置了权重规则，会进一步查询具体的规则内容 `StrategyRuleEntity`。权重规则的格式通常是这样的：`4000:102,103,104,105 5000:102,103,104,105,106,107`，表示消费4000积分的用户可以抽奖品102-105，消费5000积分的用户可以抽奖品102-107。
        
    -   然后，代码会解析这个规则，并为**每一个权重等级**（如4000分、5000分）分别创建一个**专属的奖品池**。它会筛选出该权重等级对应的奖品，然后再次调用 `assembleLotteryStrategy` 的重载方法，为这个特定的权重等级生成一个独立的概率查找表。

**算法讲解:**

这个算法的核心思想是将**概率**转换成一个**整数范围**，然后在这个范围内进行随机取值，从而实现概率抽奖。

1.  **获取最小概率值**: 找出所有奖品中最小的中奖概率。例如，有三个奖品，概率分别是 0.1, 0.02, 0.003，那么最小概率就是 0.003。
    
2.  **计算概率范围值 (`rateRange`)**: 根据最小概率值，计算出一个整数范围。这个范围的计算方法是：找到一个10的幂，使得最小概率乘以这个幂之后，结果大于等于1。
    
    -   例如，最小概率是 0.1，乘以10后是1，所以 `rateRange` 是 10。
        
    -   最小概率是 0.02，乘以100后是2，所以 `rateRange` 是 100。
        
    -   最小概率是 0.003，乘以1000后是3，所以 `rateRange` 是 1000。 这个 `rateRange` 决定了我们抽奖时随机数的最大值。
        
3.  **生成概率查找表**: 创建一个列表 `strategyAwardSearchRateTables`，然后根据每个奖品的概率和 `rateRange`，向列表中填充相应数量的奖品 ID。
    
    -   假设 `rateRange` 是 1000，某个奖品的概率是 0.1，那么就在列表中添加 `1000 * 0.1 = 100` 个该奖品的 ID。
        
    -   另一个奖品概率是 0.02，就添加 `1000 * 0.02 = 20` 个该奖品的 ID。 这样，列表中奖品ID的数量就和它的中奖概率成正比了。
        
4.  **乱序操作**: 使用 `Collections.shuffle` 将列表中的奖品 ID 完全打乱。这是为了保证抽奖的随机性。
    
5.  **生成Map集合**: 将乱序后的列表转换成一个 Map，Key 是从 0 到 `rateRange-1` 的整数，Value 是对应的奖品 ID。
    
6.  **存入Redis**: 最后，将这个 Map 存入 Redis，作为最终的概率查找表。同时，也会将 `rateRange` 的值存入 Redis，以便后续抽奖时使用。
    

#### **总结**

`assembleLotteryStrategy` 方法通过一系列精巧的设计，将复杂的抽奖逻辑预处理成一个简单高效的查找表。这种“空间换时间”的策略，使得在用户进行抽奖时，只需要生成一个随机数，然后在 Redis 中进行一次 O(1) 复杂度的查找，就能快速确定中奖结果，极大地提升了系统的性能和并发处理能力。


# 抽奖接口
#### **2. 创建抽奖资格订单 (`createOrder`)**

在正式抽奖前，系统需要确认用户有资格参与本次抽奖，并通过创建一个唯一的“抽奖单”来记录这次行为。这个关键步骤由 `raffleActivityPartakeService.createOrder` 完成。

Java

```
// 2. 参与活动 - 创建参与记录订单
UserRaffleOrderEntity orderEntity = raffleActivityPartakeService.createOrder(request.getUserId(), request.getActivityId());
log.info("活动抽奖，创建订单 userId:{} activityId:{} orderId:{}", request.getUserId(), request.getActivityId(), orderEntity.getOrderId());
```

**代码讲解:**

这个 `createOrder` 方法是抽奖资格的核心校验和凭证生成环节，其具体逻辑在 `AbstractRaffleActivityPartake` 抽象类和其实现类 `RaffleActivityPartakeService` 中。

1.  **活动状态与日期校验**:
    
    -   首先查询活动信息 `ActivityEntity`。
        
    -   检查活动状态是否为 `open`（开启）。
        
    -   检查当前时间是否在活动的 `beginDateTime` 和 `endDateTime` 之间。
        
    -   任何一项不满足，则直接抛出异常，阻止抽奖。
        
2.  **幂等性检查**:
    
    -   查询该用户在该活动下是否有状态为 `create`（已创建但未使用）的抽奖单 `UserRaffleOrderEntity`。
        
    -   如果存在，说明用户可能因为网络问题重复点击了抽奖按钮。此时系统不会创建新的抽奖单，而是直接返回之前创建的订单，保证一次抽奖行为只对应一个订单。
        
3.  **账户额度过滤 (`doFilterAccount`)**:
    
    -   这是最核心的资格校验环节，在一个方法内，通过事务性的方式，对用户的总、月、日三个维度的抽奖次数进行检查和扣减。
        
    -   **查询**：依次查询总账户 (`raffle_activity_account`)、月账户 (`raffle_activity_account_month`)、日账户 (`raffle_activity_account_day`) 的剩余次数。
        
    -   **判断**：如果任一账户的剩余次数小于等于0，则抛出对应的异常（如：`ACCOUNT_QUOTA_ERROR`, `ACCOUNT_MONTH_QUOTA_ERROR`），流程终止。
        
    -   **扣减**：如果所有校验都通过，会在后续的数据库事务中，对这三个表的剩余次数进行 `-1` 操作。
        
4.  **构建并保存订单**:
    
    -   调用 `buildUserRaffleOrder` 方法，生成一个唯一的订单ID (`orderId`)，并组装成 `UserRaffleOrderEntity` 对象。
        
    -   将上述所有需要变更的数据（账户扣减信息、新生成的订单）封装进一个聚合对象 `CreatePartakeOrderAggregate`。
        
    -   调用 `activityRepository.saveCreatePartakeOrderAggregate`，在一个数据库事务内，完成对总、月、日账户表的更新，以及新抽奖订单的插入操作。这保证了“资格校验”和“凭证生成”的原子性。

`saveCreatePartakeOrderAggregate`
**代码讲解:**

1.  **数据库路由 (`dbRouter`)**:
    
    -   在进入事务之前，代码首先调用了 `dbRouter.doRouter(userId)`。
        
    -   **作用**: 这是一个分库分表中间件的调用。它会根据 `userId` 计算出一个哈希值，决定接下来所有的数据库操作应该路由到哪个具体的数据库实例和表中。例如，`userId`为偶数的用户数据存放在`db_01`，奇数用户存放在`db_02`。
        
    -   **重要性**: 确保了与该用户相关的所有数据（总、月、日账户，以及订单）都落在同一个库中，这是实现事务的前提。
        
    -   `finally` 块中的 `dbRouter.clear()` 负责在操作结束后清理路由信息，避免影响其他线程。
        
2.  **编程式事务 (`transactionTemplate`)**:
    
    -   项目没有使用更常见的 `@Transactional` 注解，而是使用了 `TransactionTemplate` 编程式事务。
        
    -   **原因**: 编程式事务可以更精细地控制事务的边界，并且可以方便地在事务中进行手动回滚 (`status.setRollbackOnly()`)。在这里，当检查到库存扣减失败时，可以立即标记事务为回滚状态并抛出异常。
        
3.  **原子操作详解（事务内部）**:
    
    -   **第一步：更新总账户**
        
        -   调用 `raffleActivityAccountDao.updateActivityAccountSubtractionQuota`，对 `raffle_activity_account` 表执行 `UPDATE` 操作。
            
        -   SQL语句的核心是 `set total_count_surplus = total_count_surplus - 1 where ... and total_count_surplus > 0`。这是一个**乐观锁**的实现，`total_count_surplus > 0` 保证了不会超扣。
            
        -   方法会返回受影响的行数。如果行数不为1，说明库存不足或用户不存在，此时会手动回滚事务并抛出异常。
            
    -   **第二步：更新/创建月账户**
        
        -   `isExistAccountMonth` 标志位是在之前的 `doFilterAccount` 步骤中设置的。
            
        -   **更新**: 如果月账户已存在，则调用 `updateActivityAccountMonthSubtractionQuota` 扣减月剩余次数，同样使用乐观锁 (`month_count_surplus > 0`)。
            
        -   **创建**: 如果是本月第一次抽奖，则调用 `insertActivityAccountMonth`，插入一条新的月账户记录，并将剩余次数设置为 `总次数 - 1`。
            
    -   **第三步：更新/创建日账户**
        
        -   逻辑与月账户完全相同，只是操作的表是 `raffle_activity_account_day`。
            
    -   **第四步：写入抽奖订单**
        
        -   最后，调用 `userRaffleOrderDao.insert`，将新生成的 `UserRaffleOrder` 写入数据库，状态为 `create`。
            
4.  **异常处理**:
    
    -   通过 `try-catch` 捕获 `DuplicateKeyException`。这通常发生在 `user_raffle_order` 表的 `order_id` 出现重复时（尽管概率极低），此时会回滚事务，保证数据不会被污染。

#### **3. 执行核心抽奖策略 (`performRaffle`)**

获取到合法的抽奖订单后，就进入了真正的抽奖计算环节。

Java

```
// 3. 抽奖策略 - 执行抽奖
RaffleAwardEntity raffleAwardEntity = raffleStrategy.performRaffle(RaffleFactorEntity.builder()
        .userId(orderEntity.getUserId())
        .strategyId(orderEntity.getStrategyId())
        .endDateTime(orderEntity.getEndDateTime())
        .build());
```

**代码讲解:**

`performRaffle` 方法是抽奖策略的入口，它定义在 `AbstractRaffleStrategy` 抽象类中，是整个抽奖逻辑的核心调度者。它通过**责任链模式**和**规则树引擎**，分阶段、分层次地完成复杂的抽奖计算。

-   **阶段一：责任链过滤 (`raffleLogicChain`)**
    
    -   **目的**：进行前置规则的过滤，快速筛选掉不符合特定规则的用户，或者为符合特定规则的用户直接指定奖品。
        
    -   **流程**：
        
        1.  **黑名单规则 (`rule_blacklist`)**: 检查用户是否在黑名单中。如果是，则直接返回预设的兜底奖品（如1积分），并中断后续流程。
            
        2.  **权重规则 (`rule_weight`)**: 根据用户的积分或等级，判断用户是否能进入更高权重的奖品池。如果满足条件，则从对应的权重奖品池中进行抽奖。
            
        3.  **默认规则 (`rule_default`)**: 如果以上规则都未命中，则进入默认流程。此时，会从 Redis 中获取预先装配好的**全量概率查找表**，生成一个随机数，直接从查找表中取出对应的奖品ID。
            
-   **阶段二：规则树过滤 (`raffleLogicTree`)**
    
    -   **目的**：对责任链返回的初步奖品ID进行后置的、更复杂的条件校验。
        
    -   **流程**：
        
        1.  **次数锁规则 (`rule_lock`)**: 检查该奖品是否有解锁条件，比如需要用户抽奖N次后才能获得。如果用户抽奖次数未达到要求，则该奖品被“拦截”，流程会走向兜底方案。
            
        2.  **库存扣减规则 (`rule_stock`)**: 这是最关键的一步。系统会尝试对该奖品在 Redis 中的库存执行 `decr`（原子减1）操作。
            
            -   **成功**: 如果 `decr` 后的值大于等于0，说明库存扣减成功，该奖品被确认为最终中奖奖品。同时，会发送一条延迟消息到队列，用于后续异步更新数据库库存。
                
            -   **失败**: 如果 `decr` 后的值为负数，说明在并发环境下，这个奖品已经被抽完。此时，流程会走向下一个节点。
                
        3.  **兜底奖励规则 (`rule_luck_award`)**: 如果前面的规则（如次数锁、库存不足）导致无法获得原定奖品，流程会进入这个节点，返回一个预设的“幸运奖”或“安慰奖”，确保用户总能获得一个结果。
            

#### **4. 记录中奖结果 (`saveUserAwardRecord`)**

抽奖策略执行完毕后，系统拿到了最终的中奖结果 `RaffleAwardEntity`。接下来，需要将这个结果持久化。

Java

```
// 4. 存放结果 - 写入中奖记录
UserAwardRecordEntity userAwardRecord = UserAwardRecordEntity.builder()
        // ... 组装中奖记录信息
        .build();
awardService.saveUserAwardRecord(userAwardRecord);
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE5MTgzMzU2NDMsLTE1NTk5ODYzNjksLT
IwMTMyMDk1NjUsMTQ3NDgyNzIzNywtMTc5OTY5MzA3OSwtNjU4
NTA0NTcyLC0xNjc5Njc5MjgxLDQ0MDkwNTYxOV19
-->