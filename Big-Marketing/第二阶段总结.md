# 活动装配接口
第一步：活动装配activityArmory
-   **查询活动SKU列表**: 首先，通过 `activityRepository.queryActivitySkuListByActivityId` 从数据库中查询出该活动关联的所有 SKU (Stock Keeping Unit, 库存单位) 信息。每个 SKU 代表一种可参与的活动商品或资格。
    
-   **缓存SKU库存**: 遍历查询到的 SKU 列表，然后调用 `cacheActivitySkuStockCount` 方法。这个方法会将每个 SKU 的剩余库存数量 (`stockCountSurplus`) 存入 Redis 缓存。缓存的 Key 由一个固定的前缀 (`big_market_activity_sku_key_`) 和 SKU ID 拼接而成。
    
-   **预热活动次数**: 在循环中，还会调用 `activityRepository.queryRaffleActivityCountByActivityCountId`。这个方法会查询活动可参与的次数限制（总次数、每日次数、每月次数），并将查询结果缓存起来，供后续的抽奖资格校验使用。
    
-   **预热活动信息**: 最后，调用 `activityRepository.queryRaffleActivityByActivityId` 来查询活动的基本信息（如活动名称、描述、时间等），并将其缓存。


第二步：策略装配
-   **查询策略配置**: 方法首先通过 `repository.queryStrategyAwardList(strategyId)` 从数据库（或缓存）中获取该策略ID下配置的所有奖品列表 `strategyAwardEntities`。这个列表包含了每个奖品的ID、概率、剩余库存等信息。
    
-   **缓存奖品库存**: 遍历奖品列表，调用 `cacheStrategyAwardCount` 方法，将每个奖品的剩余库存数量 (`awardCountSurplus`) 存入 Redis。这是一个 `AtomicLong` 类型的原子计数器，用于后续抽奖时进行安全的库存扣减。
    
-   **默认装配 (全量抽奖概率)**: 调用 `assembleLotteryStrategy` 的重载方法，对**所有奖品**进行装配。这是默认的、最基础的抽奖池。我们稍后会深入讲解这个重载方法的内部实现。
    
-   **权重策略配置**:
    
    -   首先，查询策略实体 `StrategyEntity`，检查是否配置了权重规则 (`ruleWeight`)。
        
    -   如果配置了权重规则，会进一步查询具体的规则内容 `StrategyRuleEntity`。权重规则的格式通常是这样的：`4000:102,103,104,105 5000:102,103,104,105,106,107`，表示消费4000积分的用户可以抽奖品102-105，消费5000积分的用户可以抽奖品102-107。
        
    -   然后，代码会解析这个规则，并为**每一个权重等级**（如4000分、5000分）分别创建一个**专属的奖品池**。它会筛选出该权重等级对应的奖品，然后再次调用 `assembleLotteryStrategy` 的重载方法，为这个特定的权重等级生成一个独立的概率查找表。

**算法讲解:**

这个算法的核心思想是将**概率**转换成一个**整数范围**，然后在这个范围内进行随机取值，从而实现概率抽奖。

1.  **获取最小概率值**: 找出所有奖品中最小的中奖概率。例如，有三个奖品，概率分别是 0.1, 0.02, 0.003，那么最小概率就是 0.003。
    
2.  **计算概率范围值 (`rateRange`)**: 根据最小概率值，计算出一个整数范围。这个范围的计算方法是：找到一个10的幂，使得最小概率乘以这个幂之后，结果大于等于1。
    
    -   例如，最小概率是 0.1，乘以10后是1，所以 `rateRange` 是 10。
        
    -   最小概率是 0.02，乘以100后是2，所以 `rateRange` 是 100。
        
    -   最小概率是 0.003，乘以1000后是3，所以 `rateRange` 是 1000。 这个 `rateRange` 决定了我们抽奖时随机数的最大值。
        
3.  **生成概率查找表**: 创建一个列表 `strategyAwardSearchRateTables`，然后根据每个奖品的概率和 `rateRange`，向列表中填充相应数量的奖品 ID。
    
    -   假设 `rateRange` 是 1000，某个奖品的概率是 0.1，那么就在列表中添加 `1000 * 0.1 = 100` 个该奖品的 ID。
        
    -   另一个奖品概率是 0.02，就添加 `1000 * 0.02 = 20` 个该奖品的 ID。 这样，列表中奖品ID的数量就和它的中奖概率成正比了。
        
4.  **乱序操作**: 使用 `Collections.shuffle` 将列表中的奖品 ID 完全打乱。这是为了保证抽奖的随机性。
    
5.  **生成Map集合**: 将乱序后的列表转换成一个 Map，Key 是从 0 到 `rateRange-1` 的整数，Value 是对应的奖品 ID。
    
6.  **存入Redis**: 最后，将这个 Map 存入 Redis，作为最终的概率查找表。同时，也会将 `rateRange` 的值存入 Redis，以便后续抽奖时使用。
    

#### **总结**

`assembleLotteryStrategy` 方法通过一系列精巧的设计，将复杂的抽奖逻辑预处理成一个简单高效的查找表。这种“空间换时间”的策略，使得在用户进行抽奖时，只需要生成一个随机数，然后在 Redis 中进行一次 O(1) 复杂度的查找，就能快速确定中奖结果，极大地提升了系统的性能和并发处理能力。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTQ3NDgyNzIzNywtMTc5OTY5MzA3OSwtNj
U4NTA0NTcyLC0xNjc5Njc5MjgxLDQ0MDkwNTYxOV19
-->