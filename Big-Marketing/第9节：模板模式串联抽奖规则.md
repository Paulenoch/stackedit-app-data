### 核心思想：模板方法模式贯穿始终

在你提到的“模板模式是如何将这些抽奖规则串联起来的”，这正是整个抽奖流程设计的核心。

核心类是 `Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/AbstractRaffleStrategy.java`。

这个抽象类定义了抽奖过程的**标准骨架（模板）**，它规定了抽奖必须经过的几个关键步骤，但允许子类去实现某些具体步骤的细节。

我们来看一下它的核心方法 `performRaffle`：

Java

```
// in AbstractRaffleStrategy.java
public RaffleAwardEntity performRaffle(RaffleFactorEntity raffleFactorEntity) {
    // 1. 参数校验
    String userId = raffleFactorEntity.getUserId();
    Long strategyId = raffleFactorEntity.getStrategyId();
    if (null == strategyId || StringUtils.isBlank(userId)) {
        return null;
    }

    // 2. 责任链抽奖前置规则过滤
    RuleActionEntity<RuleActionEntity.RaffleBeforeEntity> ruleActionEntity = this.doCheckRaffleBeforeLogic(RaffleFactorEntity.builder()
            .userId(userId)
            .strategyId(strategyId)
            .build());
    if (null != ruleActionEntity) {
        // 如果规则有拦截，则直接返回
        return RaffleAwardEntity.builder()
                .awardDesc(ruleAction_before.getInfo())
                .build();
    }

    // 3. 默认抽奖策略
    // ... 获取抽奖奖品列表和规则 ...
    Integer awardId = this.doCheckRaffleAfterLogic(ruleAction_after);

    // 4. 封装结果
    return RaffleAwardEntity.builder()
            .awardId(awardId)
            .build();
}
```

从上面的代码可以看出，`performRaffle` 方法定义了一个清晰的执行流程：

1.  **参数校验**：最基本的检查。
    
2.  **抽奖前置过滤（`doCheckRaffleBeforeLogic`）**：执行一系列抽奖资格的校验，比如黑名单、抽奖次数限制等。这是一个**抽象方法**，需要子类去实现。
    
3.  **执行核心抽奖逻辑（`doCheckRaffleAfterLogic`）**：在通过所有前置校验后，执行真正的抽奖计算，得出中奖的奖品ID。这也是一个**抽象方法**。
    
4.  **结果封装**：将抽奖结果包装成统一的格式返回。
    

`DefaultRaffleStrategy.java` 作为 `AbstractRaffleStrategy` 的默认实现类，具体实现了 `doCheckRaffleBeforeLogic` 和 `doCheckRaffleAfterLogic` 这两个核心抽象方法，从而完成了整个抽奖流程的闭环。

接下来，我们详细分析每一步。

----------

### 第一步：抽奖资格校验（前置规则过滤）

这一步由 `DefaultRaffleStrategy.java` 中的 `doCheckRaffleBeforeLogic` 方法实现，其核心是**责任链模式**的应用。

-   **文件位置**: `Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/raffle/DefaultRaffleStrategy.java`
    
-   **调用函数**: `doCheckRaffleBeforeLogic(RaffleFactorEntity raffleFactorEntity)`
    

#### 代码实现与函数调用：

1.  **获取责任链**:
    
    -   `doCheckRaffleBeforeLogic` 首先会调用 `defaultChainFactory.openLogicChain(strategyId)`。
        
    -   这个 `openLogicChain` 方法位于 `Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/chain/factory/DefaultChainFactory.java`。
        
    -   `DefaultChainFactory` 会从 `IStrategyRepository` 查询该策略（`strategyId`）配置的所有规则（例如：`rule_blacklist`、`rule_weight`）。
        
    -   然后，它会根据查询到的规则名称，从 Spring 容器中获取对应的责任链节点（`ILogicChain` 的实现类，如 `BlackListLogicChain`、`RuleWeightLogicChain`），并将它们按照配置的顺序组装成一个完整的责任链。
        
2.  **执行责任链**:
    
    -   拿到责任链的头节点后，调用 `logicChain.logic(userId, strategyId)` 开始执行。
        
    -   责任链的执行起点是 `Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/chain/AbstractLogicChain.java` 中的 `logic` 方法。
        
    -   该方法首先调用 `logic` 抽象方法，由具体的实现类（如 `BlackListLogicChain`）执行自己的校验逻辑。
        
    -   如果当前节点校验通过，则通过 `next()` 方法将请求传递给下一个节点，直到所有节点都执行完毕。
        

#### 涉及的设计模式：

-   **责任链模式 (Chain of Responsibility)**: 将多个规则校验对象（`BlackListLogicChain`, `RuleWeightLogicChain` 等）链接成一条链。当抽奖请求到来时，它会沿着这条链传递，每个节点都有机会处理请求。如果某个节点发现不满足条件（例如用户在黑名单中），它可以中断链的传递，直接返回拦截结果。这使得规则的增加、删除和重新排序变得非常灵活，无需修改现有代码。
    
-   **工厂模式 (Factory)**: `DefaultChainFactory` 负责创建和组装责任链。它隐藏了责任链构建的复杂细节，调用者只需要通过 `openLogicChain(strategyId)` 就能获取一个配置好的责任链实例。
    

----------

### 第二步：核心抽奖计算（后置规则过滤）

当所有前置资格校验都通过后，就进入了真正的“抽奖”环节。这一步的核心是**策略模式**和**决策树（规则树）模式**。

-   **文件位置**: `Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/raffle/DefaultRaffleStrategy.java`
    
-   **调用函数**: `doCheckRaffleAfterLogic(RuleMatterEntity ruleMatterEntity)`
    

#### 代码实现与函数调用：

1.  **获取抽奖算法**:
    
    -   `doCheckRaffleAfterLogic` 方法首先会通过 `strategyRepository.queryStrategyAwardRuleModelVO(strategyId)` 获取该策略配置的抽奖规则模型，其中包含了具体的抽奖算法（例如是“必中奖”还是“概率抽奖”）。
        
    -   然后调用 `strategyDispatch.getRandomAwardId(strategyId)` 来执行抽奖。
        
2.  **执行概率计算 (`strategyDispatch`)**:
    
    -   `strategyDispatch` 的实现类是 `StrategyArmoryDispatch` (`Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/armory/StrategyArmoryDispatch.java`)。
        
    -   `getRandomAwardId(strategyId)` 方法会先从缓存（一个 `Map`）中查询该策略的概率分布数据。如果缓存中没有，它会调用 `strategyRepository.queryStrategyAwardList(strategyId)` 从数据库加载奖品列表及其权重。
        
    -   加载后，它会调用 `assembleKeyToStrategyAward(strategyId, strategyAwardList)` 方法，根据每个奖品的权重（`awardRate`）生成一个**概率区间**。例如，A奖品概率10%，B奖品概率30%，C奖品概率60%，那么会生成一个1到100的范围，1-10对应A，11-40对应B，41-100对应C。这个过程被称为**“打乱散列表”**或**“范围乱序”**。
        
    -   最后，生成一个随机数，看它落在哪个区间，就返回哪个奖品的ID。
        
3.  **执行规则树过滤 (`decisionTreeEngine`)**:
    
    -   在通过概率计算得到一个初步的奖品ID后，系统还需要检查一些更复杂的规则，例如“库存”、“活动时间限制”等。这时就用到了**规则树**。
        
    -   `doCheckRaffleAfterLogic` 会调用 `decisionTreeEngine.process(...)`。
        
    -   `decisionTreeEngine` 的实现是 `DecisionTreeEngine` (`Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/factory/engine/impl/DecisionTreeEngine.java`)。
        
    -   `process` 方法会根据策略配置的规则树ID，从 `DefaultTreeFactory` 获取一个构建好的规则树。
        
    -   它从规则树的根节点（`tree_root`）开始执行，每个节点（`ILogicTreeNode`）代表一个决策逻辑。
        
    -   例如，第一个节点可能是 `RuleStockLogicTreeNode`（库存节点），它会检查当前抽中的奖品库存是否充足。
        
    -   如果库存充足，它会根据节点间的连接线（`RuleTreeNodeLineVO`）决定下一个要执行的节点，可能是 `RuleLuckAwardLogicTreeNode`（幸运奖节点）或者直接返回成功。
        
    -   如果库存不足，它可能会走向另一个分支，比如返回一个“兜底奖”或者提示“已售罄”。
        
    -   这个过程会一直持续，直到走到某个叶子节点，返回最终的抽奖结果。
        

#### 涉及的设计模式：

-   **策略模式 (Strategy)**: `IStrategyDispatch` 定义了抽奖算法的接口，允许系统在运行时动态地切换不同的抽奖算法（尽管当前实现 `StrategyArmoryDispatch` 主要是基于权重的随机抽奖）。
    
-   **决策树/规则引擎**: 规则树（`RuleTree`）将复杂的业务规则（库存、时间、用户等级等）模型化为一个树形结构。每个节点负责一项单一的决策逻辑。通过这棵树，系统可以灵活、清晰地处理各种复杂的组合条件，而不需要写大量的 `if-else` 语句。这使得业务规则的管理和扩展变得非常方便。
    
-   **工厂模式 (Factory)**: `DefaultTreeFactory` 负责从数据库加载规则树的配置，并将其构建成一个可执行的规则树对象。它封装了规则树的创建逻辑。
    

----------

### 总结：一次完整的抽奖之旅

现在，我们把整个流程串起来，看看一次完整的抽奖请求是如何在代码世界里旅行的：

1.  **入口**: `DefaultRaffleStrategy.performRaffle(raffleFactorEntity)` 被调用。
    
2.  **模板方法启动**: `AbstractRaffleStrategy` 的 `performRaffle` 方法作为模板，开始执行。
    
3.  **前置校验 (责任链)**:
    
    -   调用 `doCheckRaffleBeforeLogic`。
        
    -   `DefaultChainFactory` 创建一个责任链（如 `BlackListLogicChain` -> `RuleWeightLogicChain`）。
        
    -   请求在链上传递，进行黑名单、权重等资格校验。如果任一环节失败，流程中断，返回拦截信息。
        
4.  **核心抽奖**:
    
    -   资格校验通过后，调用 `doCheckRaffleAfterLogic`。
        
    -   `StrategyArmoryDispatch` 根据奖品权重进行**概率抽奖**，初步选出一个 `awardId`。
        
5.  **后置过滤 (规则树)**:
    
    -   将上一步得到的 `awardId` 和其他抽奖信息送入 `DecisionTreeEngine`。
        
    -   规则树从根节点开始执行，依次进行**库存校验 (`RuleStockLogicTreeNode`)**、**兜底奖判断 (`RuleLuckAwardLogicTreeNode`)** 等一系列精细化规则过滤。
        
    -   规则树最终返回一个经过所有规则校验后的 `awardId`。
        
6.  **返回结果**: `performRaffle` 方法将最终的 `awardId` 封装到 `RaffleAwardEntity` 中并返回。
    

这个设计非常精妙，通过组合运用**模板方法**、**责任链**、**策略**和**规则树**等多种设计模式，构建了一个高度灵活、可扩展且逻辑清晰的抽奖系统。希望这个详细的分析能帮助你理解它的运作机制！
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTQ2MzQxNzk0XX0=
-->