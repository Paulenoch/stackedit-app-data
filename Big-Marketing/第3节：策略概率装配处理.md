# 装配期（StrategyArmory.assembleLotteryStrategy）

1.  **取配置**  
    先从 Redis 读 `STRATEGY_AWARD_KEY{strategyId}`；没有就查库（`IStrategyAwardDao`）拿到 `StrategyAward` 列表，转成 `StrategyAwardEntity`，并把列表缓存回 Redis，方便下次装配直接使用。
    
2.  **数据校验**  
    过滤掉 `awardId == null`、`awardRate <= 0` 的项（避免脏数据进入查找表、写 Redis 时被 Redisson 拒绝）。
    
3.  **离散化单位（步长）**
    
    -   计算 **最小中奖概率** `minAwardRate` 和 **总概率** `totalAwardRate`。
        
    -   令 `rateRange = ceil(totalAwardRate / minAwardRate)`。  
        含义：用“最小概率”当作一个最小刻度，把所有概率都映射成整数个“格子”。
        
4.  **构建概率查找表（权重展开）**  
    为每个奖品计算 `count = ceil(rateRange * awardRate)`，向列表中**重复插入 `awardId`** `count` 次。  
    这样列表里每个奖品的占位数≈它的概率权重。
    
5.  **打乱顺序**  
    `Collections.shuffle` 随机打乱列表，避免同一奖品的格子扎堆。
    
6.  **转索引映射**  
    把列表转换为 `Map<Integer, Integer>`（`index -> awardId`）。后续会用“随机索引”直查出奖品。
    
7.  **落盘 Redis（共享给所有应用实例）**
    
    -   `STRATEGY_RATE_RANGE_KEY{strategyId}` = **查找表长度**（注意：这里实际存的是列表最终长度）。
        
    -   `STRATEGY_RATE_TABLE_KEY{strategyId}` = **整张索引→奖品ID的映射表**（Redisson 的 RMap）。
        

> 这一步是**幂等**的：可以重复装配。要更严谨，建议在 `putAll` 之前清空老表或直接覆盖，避免“新表更短时”残留旧键。

# 抽奖期（StrategyArmory.getRandomAwardId）

1.  **取范围**：从 Redis 读取 `rateRange`。
    
2.  **出随机数**：`SecureRandom().nextInt(rateRange)` 生成 `[0, rateRange)` 的随机索引。
    
3.  **查结果**：用这个索引去 Redis 的 `STRATEGY_RATE_TABLE_KEY{strategyId}` 取 `awardId`，作为本次抽中的奖品。
    

# 这套机制的性质

-   **概率近似**：每个奖品被抽中的概率 ≈ `该奖品格子数 / 总格子数`。  
    例：若三奖品 A/B/C 概率 0.5/0.3/0.2，`min=0.2`、`total=1.0`，`rateRange=ceil(1/0.2)=5`；  
    展开后格子数约为 A=3、B=2、C=1（取整上取），最终表长 6，概率约 0.5/0.333/0.167，会有**轻微的取整偏差**（总体可接受；需要更精确可用“最大剩余法”做配额分配或改用别的权重算法）。
    
-   **分布式共享**：装配结果放在 Redis，全量实例共享；抽奖节点无需本地内存表，直接按索引查 Redis。
    
-   **安全性**：用 `SecureRandom` 生成随机数，比 `Random` 质量更高。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM4MjIxMzk0N119
-->