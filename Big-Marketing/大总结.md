# 抽奖接口draw
1. 创建抽奖订单 (`createOrder`): 
-    为用户创建一张抽奖单。检查活动状态和是或否再活动日期内
- 查询是否有状态为created（创建了但未被使用）的订单
- 检查用户是否有足够的抽奖次数（日账户或月账户若不存在则创建），并返回账户构建对象（聚合对象）
- 将订单实体填充进账户构建对象中
- 根据user_id进行分库分表路由，在一个事务中更新总/日/月账户，写入参与活动订单，更新失败则回滚

 ---
    
2. 执行抽奖策略 (`performRaffle`)**: 拿到抽奖单后，调用`raffleStrategy`来执行核心的抽奖算法，决定用户中了什么奖。
    
-   保存中奖记录 (`saveUserAwardRecord`): 抽奖成功后，调用`awardService`将中奖记录保存到数据库。



# 接口限流实现细节
1. 定义限流注解@RateLimiterAccessInterceptor
-   `key()`: 用于指定限流的依据。比如，在抽奖接口中，我们希望对每个用户进行限流，那么就可以将`key`设置为`"userId"`。AOP会从请求参数中获取`userId`的值，并为每个`userId`创建一个独立的限流器。
    
-   `permitsPerSecond()`: 这是核心的限流参数，表示**每秒允许的请求次数**。例如，设置为`1.0d`就表示每秒只允许1次请求。
    
-   `blacklistCount()`: 黑名单阈值。如果一个用户在被限流后仍然持续请求，当被拦截的次数超过这个阈值时，该用户就会被加入黑名单（默认24小时），后续所有请求都会被直接拒绝。
    
-   `fallbackMethod()`: 降级方法。当请求被限流时，程序会调用这个指定的方法来返回一个友好的提示，而不是直接报错。

2. 实现AOP切面逻辑`RateLimiterAOP`
-   **动态开关**：`rateLimiterSwitch`字段通过`@DCCValue`注解注入，它的值来自Zookeeper。在AOP逻辑的开始，会先判断这个开关的状态。
    
-   **Guava Cache**: AOP切面中使用了两个Guava的Cache。
    
    -   `loginRecord`: 用来存储每个用户（由`keyAttr`标识）对应的`RateLimiter`实例。设置了1分钟的过期时间，意味着如果一个用户1分钟内没有请求，他的限流器就会被回收，下次请求时会重新创建。
        
    -   `blacklist`: 用来存储被加入黑名单的用户及其被拦截的次数。黑名单有效期为24小时。
        
-   **获取限流器**: 当一个请求进来时，会根据`keyAttr`（例如，`userId`的值 "xiaofuge"）去`loginRecord`缓存中查找对应的`RateLimiter`。如果找不到，就根据注解上配置的`permitsPerSecond`创建一个新的，并存入缓存。
    
-   **`tryAcquire()`**: 这是Guava `RateLimiter`的核心方法。它会尝试获取一个令牌，如果成功（在设定的速率范围内），则返回`true`；如果失败（请求过于频繁），则立即返回`false`。
    
-   **拦截与降级**: 如果`tryAcquire()`返回`false`，说明请求被限流了。此时，程序会更新黑名单计数，并调用注解中指定的`fallbackMethod`方法，将该方法的返回值作为接口的响应返回给用户。
    
-   **放行**: 如果`tryAcquire()`返回`true`，说明请求在允许的频率内，程序会调用`jp.proceed()`来执行原始的接口方法逻辑。

# 接口降级与熔断
### 降级
1. 定义了一个自定义注解`@DCCValue`，用于将Zookeeper中的配置项动态注入到Spring Bean的字段中。
2. 实现Bean后置处理器 (`DCCValueBeanFactory`)
- `DCCValueBeanFactory`会在Spring Bean初始化之后，检查Bean中是否有被`@DCCValue`注解的字段。
- 这个类做了两件核心事情： **初始化注入**: 在Bean初始化时，它会读取`@DCCValue`注解，从Zookeeper中拉取对应节点的数据，并通过反射将值赋给字段。**动态监听**: 它会向Zookeeper注册一个监听器。当Zookeeper中对应的节点数据发生变化时（例如，运维人员通过接口将`degradeSwitch`的值从`"close"`改成`"open"`），监听器会捕捉到这个变化，并实时地更新`RaffleActivityController`中`degradeSwitch`字段的值。

### 熔断
1. 添加Hystrix注解 (`@HystrixCommand`)：设置Hystrixj超时时间为150毫秒，若超过150毫秒自动失败，fallbackMethod：当方法执行超时/方法内部抛出任何未被捕获的异常/在达到一定的失败率后熔断器打开（Open），后续的所有请求都会直接调用降级方法
<!--stackedit_data:
eyJoaXN0b3J5IjpbNTA1MzA5ODQsLTEyOTU1MjUxNDcsMTU2OT
ExMzc2MV19
-->