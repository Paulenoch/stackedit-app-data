# 抽奖接口draw
1. 创建抽奖订单 (`createOrder`): 
- 为用户创建一张抽奖单。检查活动状态和是或否再活动日期内
- 查询是否有状态为created（创建了但未被使用）的订单
- 检查用户是否有足够的抽奖次数（日账户或月账户若不存在则创建），并返回账户构建对象（聚合对象）
- 将订单实体填充进账户构建对象中
- 根据user_id进行分库分表路由，在一个事务中更新总/日/月账户，写入参与活动订单，更新失败则回滚

 ---
    
2. 执行抽奖策略 (`performRaffle`)**: 拿到抽奖单后，调用`raffleStrategy`来执行核心的抽奖算法，决定用户中了什么奖。
- 责任链：负责抽奖**前**的资格审查和初步筛选。它像一条流水线，请求（抽奖用户）在上面依次经过各个检查点，看是否满足特殊规则（如黑名单、权重）
- -   **进入 `BlackListLogicChain`**:
    
    -   **判断**：用户 `userId` 是否在黑名单配置中？
        
    -   **是**：返回安慰奖 `awardId`，流程结束。
        
    -   **否**：调用 `next().logic(...)`，将请求传递给 `RuleWeightLogicChain`。
        
- -   **进入 `RuleWeightLogicChain`**:
    
    -   **判断**：用户的总参与次数是否达到某个权重档位？
        
    -   **是**：从该档位的奖品池抽奖，返回 `awardId`，流程结束。
        
    -   **否**：调用 `next().logic(...)`，将请求传递给 `DefaultLogicChain`。
        
- -  **进入 `DefaultLogicChain`**:
    
    -   **执行**：不再有判断，直接执行全局概率抽奖，返回一个 `awardId`。流程结束。

整体蓝图 - `RuleTreeVO`，决策点 - `RuleTreeNodeVO`，分支路径 - `RuleTreeNodeLineVO`

- 规则树：负责抽奖**后**的结果校验和最终裁定。当责任链给出一个初步的奖品后，规则树会对这个“中奖结果”进行一系列校验（如库存、解锁条件），并给出最终的
- **示例流程**: 假设一个奖品的规则树是 `[次数解锁] -> [库存扣减] -> [兜底奖]`

1.  **进入 `RuleLockLogicTreeNode`**:
    
    -   **决策**：用户抽奖次数是否 > 10次？
        
    -   **是 (`ALLOW`)**：引擎根据 `RuleTreeNodeLine` 的配置，找到 `ALLOW` 分支对应的下一个节点是 `RuleStockLogicTreeNode`。
        
    -   **否 (`TAKE_OVER`)**：引擎找到 `TAKE_OVER` 分支对应的下一个节点是 `RuleLuckAwardLogicTreeNode`（或者直接返回一个“未解锁”的结果）。
        
2.  **进入 `RuleStockLogicTreeNode`**:
    
    -   **决策**：奖品库存 > 0 吗？
        
    -   **是 (`TAKE_OVER`)**：扣减库存成功，引擎“接管”并返回**当前奖品ID**作为最终结果，流程结束。
        
    -   **否 (`ALLOW`)**：库存不足，引擎“放行”，根据 `ALLOW` 分支找到下一个节点是 `RuleLuckAwardLogicTreeNode`。
        
3.  **进入 `RuleLuckAwardLogicTreeNode`**:
    
    -   **决策**：这是一个终点，直接“接管”并返回一个配置好的**兜底奖品ID**。流程结束。
    
-   保存中奖记录 (`saveUserAwardRecord`): 抽奖成功后，调用`awardService`将中奖记录保存到数据库。

 ### 工厂模式的作用
 -   **解耦**：使用者 `DefaultRaffleStrategy` 完全不需要关心责任链内部有多少个节点、它们的顺序是什么。它只需要向工厂请求一个针对特定策略ID的责任链即可。
    
-   **封装创建逻辑**：将复杂的、依赖于配置的链条组装逻辑封装在了工厂内部。如果未来新增了一个“VIP规则”，`DefaultRaffleStrategy`的代码完全不用动，只需要实现新的规则类，并在数据库中配置进去，工厂就能自动把它组装到链条里。

### 具体抽奖算法
1.  **离散化单位（步长）**
    
    -   计算 **最小中奖概率** `minAwardRate` 和 **总概率** `totalAwardRate`。
        
    -   令 `rateRange = ceil(totalAwardRate / minAwardRate)`。  
        含义：用“最小概率”当作一个最小刻度，把所有概率都映射成整数个“格子”。
        
2.  **构建概率查找表（权重展开）**  
    为每个奖品计算 `count = ceil(rateRange * awardRate)`，向列表中**重复插入 `awardId`** `count` 次。  
    这样列表里每个奖品的占位数≈它的概率权重。
    
3.  **打乱顺序**  
    `Collections.shuffle` 随机打乱列表，避免同一奖品的格子扎堆。
    
4.  **转索引映射**  
    把列表转换为 `Map<Integer, Integer>`（`index -> awardId`）。后续会用“随机索引”直查出奖品。

# 消息队列
### **1. 场景一：异步发放奖品**
    
-   **解决方案**:
    
    1.  **核心流程（同步）**: `AwardRepository` 在用户中奖后，只做最核心的两件事：将中奖记录写入数据库（`user_award_record`表），并将一条“待发送的发奖消息”写入`task`表。这两个操作被包裹在一个本地事务中，保证了“中奖”和“发奖消息”的原子性。
        
    2.  **消息发送（事务外）**: 在本地事务成功提交后，立即尝试将发奖消息（`SendAwardMessageEvent`）发布到 RabbitMQ 的 `send_award` 主题。
        
    3.  **非核心流程（异步）**: `SendAwardCustomer` 监听器作为独立的消费者，订阅 `send_award` 主题。当收到消息后，它会解析消息内容，并调用 `IAwardService` 的 `distributeAward` 方法来执行具体的发奖逻辑。
        
-   **效果**: 抽奖接口的响应时间大大缩短，因为它不再等待发奖完成。发奖服务的成功与否不影响用户抽奖的体验，系统整体的吞吐量和可用性得到了提升。
    

### **2. 场景二：异步处理行为返利**

这个场景与异步发奖类似，用于处理用户完成某个行为（如签到）后的奖励发放。

-   **问题**: 用户签到后，系统需要根据预设的返利规则给予奖励，奖励可能是增加抽奖次数（SKU），也可能是增加积分。这些后台操作同样不需要用户实时等待。
    
-   **解决方案**:
    
    1.  **生产者**: `BehaviorRebateService` 在创建返利订单时，同样会将返利任务信息封装成 `SendRebateMessageEvent` 消息，并写入`task`表，然后发布到 `send_rebate` 主题。
        
    2.  **消费者**: `RebateMessageCustomer` 监听 `send_rebate` 主题。收到消息后，它会判断返利类型（`rebateType`）：
        
        -   如果是 `sku`，则调用 `raffleActivityAccountQuotaService` 为用户增加抽奖次数。
            
        -   如果是 `integral`，则调用 `creditAdjustService` 为用户增加积分。
            
-   **效果**: 用户签到接口可以瞬间响应，后台的记账和发奖流程异步执行，实现了流程解耦。
    

### **3. 场景三：领域间通信与最终一致性**

这是更高级的用法，利用消息队列解耦不同领域（Domain）之间的依赖，并通过事件驱动的方式实现最终一致性。

-   **问题**: “积分兑换商品”这个业务，横跨了“积分域（Credit Domain）”和“活动域（Activity Domain）”。流程是：1. 扣减用户积分；2. 为用户增加抽奖次数。如果采用同步调用的方式，两个领域将紧密耦合，且需要处理复杂的分布式事务。
    
-   **解决方案**: **事件驱动架构**
    
    1.  **积分域**: 当用户兑换时，`CreditRepository` 负责**扣减积分**，并在同一个本地事务中，将一个“积分调整成功”的消息（`CreditAdjustSuccessMessageEvent`）写入 `task` 表。
        
    2.  **发布事件**: 事务成功后，积分域发布这个事件到 `credit_adjust_success` 主题。
        
    3.  **活动域**: `CreditAdjustSuccessCustomer` 监听这个主题。收到消息后，它才知道积分已经成功扣除，然后**安全地**调用 `raffleActivityAccountQuotaService.updateOrder` 方法，为用户的活动账户增加相应的抽奖次数。
        
-   **效果**: 积分域和活动域之间没有直接的代码依赖，它们通过消息进行通信。这大大降低了系统的耦合度，使得两个领域可以独立开发和部署。虽然在消息传递的短暂时间内数据可能不一致（积分扣了但次数还没加），但系统最终会达到一致的状态。
    

### **4. 场景四：库存扣减的最终一致性**

-   **问题**: 活动SKU的库存扣减是一个高并发场景。如果每次都直接操作数据库，会给数据库带来巨大压力。
    
-   **解决方案**:
    
    1.  **Redis预扣减**: 绝大部分的库存扣减操作都在高性能的Redis中完成。
        
    2.  **发消息通知**: 当Redis中的库存被扣减为0时，`ActivityRepository`会发布一个`ActivitySkuStockZeroMessageEvent`消息到`activity_sku_stock_zero`主题。
        
    3.  **异步更新DB**: `ActivitySkuStockZeroCustomer`监听到此消息后，会去更新数据库中的库存状态，将其也清零，从而保证了数据库和缓存的最终一致性。
        
-   **效果**: 将库存压力从数据库转移到了Redis，大大提高了系统的并发能力。
    

### **高可用保障：基于`task`表的可靠消息投递**

以上所有场景都依赖于消息的可靠投递。如果生产者发送消息失败（比如RabbitMQ宕机），怎么办？项目采用了一种非常经典的**“事务消息最终一致性”**方案，也叫**“Transactional Outbox”模式**。

1.  **写入`task`表**: 在执行业务操作（如创建中奖记录、创建返利订单）的**同一个本地事务**中，将要发送的MQ消息的完整内容、目标主题等信息，以`state = 'create'`的状态存入`task`表中。
    
2.  **尝试发送**: 事务提交后，程序尝试将消息发送到RabbitMQ。
    
3.  **更新状态**: 如果发送成功，就将`task`表中对应的记录状态更新为`'completed'`。如果失败，则更新为`'fail'`。
    
4.  **定时任务补偿**: 有一个名为`SendMessageTaskJob`的定时任务，它会**每隔5秒**扫描所有分库分表的`task`表，找出所有状态为`'fail'`或长时间处于`'create'`状态的消息。
    
5.  **重新投递**: 定时任务会把这些“失败”的消息重新投递到RabbitMQ，直到成功为止。
    

**效果**: 这种机制确保了即使在消息中间件短暂不可用或网络抖动的情况下，业务消息也**绝对不会丢失**，保证了业务的最终一致性。

综上所述，`Big-Market`项目对消息队列的应用是系统性的、多层次的，它不仅仅是简单地用MQ来异步执行任务，更是将其作为分布式系统架构中解耦、削峰、保证最终一致性的核心组件，并配以强大的可靠性投递机制，是教科书级别的工程实践。

# 接口限流实现细节
1. 定义限流注解@RateLimiterAccessInterceptor
-   `key()`: 用于指定限流的依据。比如，在抽奖接口中，我们希望对每个用户进行限流，那么就可以将`key`设置为`"userId"`。AOP会从请求参数中获取`userId`的值，并为每个`userId`创建一个独立的限流器。
    
-   `permitsPerSecond()`: 这是核心的限流参数，表示**每秒允许的请求次数**。例如，设置为`1.0d`就表示每秒只允许1次请求。
    
-   `blacklistCount()`: 黑名单阈值。如果一个用户在被限流后仍然持续请求，当被拦截的次数超过这个阈值时，该用户就会被加入黑名单（默认24小时），后续所有请求都会被直接拒绝。
    
-   `fallbackMethod()`: 降级方法。当请求被限流时，程序会调用这个指定的方法来返回一个友好的提示，而不是直接报错。

2. 实现AOP切面逻辑`RateLimiterAOP`
-   **动态开关**：`rateLimiterSwitch`字段通过`@DCCValue`注解注入，它的值来自Zookeeper。在AOP逻辑的开始，会先判断这个开关的状态。
    
-   **Guava Cache**: AOP切面中使用了两个Guava的Cache。
    
    -   `loginRecord`: 用来存储每个用户（由`keyAttr`标识）对应的`RateLimiter`实例。设置了1分钟的过期时间，意味着如果一个用户1分钟内没有请求，他的限流器就会被回收，下次请求时会重新创建。
        
    -   `blacklist`: 用来存储被加入黑名单的用户及其被拦截的次数。黑名单有效期为24小时。
        
-   **获取限流器**: 当一个请求进来时，会根据`keyAttr`（例如，`userId`的值 "xiaofuge"）去`loginRecord`缓存中查找对应的`RateLimiter`。如果找不到，就根据注解上配置的`permitsPerSecond`创建一个新的，并存入缓存。
    
-   **`tryAcquire()`**: 这是Guava `RateLimiter`的核心方法。它会尝试获取一个令牌，如果成功（在设定的速率范围内），则返回`true`；如果失败（请求过于频繁），则立即返回`false`。
    
-   **拦截与降级**: 如果`tryAcquire()`返回`false`，说明请求被限流了。此时，程序会更新黑名单计数，并调用注解中指定的`fallbackMethod`方法，将该方法的返回值作为接口的响应返回给用户。
    
-   **放行**: 如果`tryAcquire()`返回`true`，说明请求在允许的频率内，程序会调用`jp.proceed()`来执行原始的接口方法逻辑。

# 接口降级与熔断
### 降级
1. 定义了一个自定义注解`@DCCValue`，用于将Zookeeper中的配置项动态注入到Spring Bean的字段中。
2. 实现Bean后置处理器 (`DCCValueBeanFactory`)
- `DCCValueBeanFactory`会在Spring Bean初始化之后，检查Bean中是否有被`@DCCValue`注解的字段。
- 这个类做了两件核心事情： **初始化注入**: 在Bean初始化时，它会读取`@DCCValue`注解，从Zookeeper中拉取对应节点的数据，并通过反射将值赋给字段。**动态监听**: 它会向Zookeeper注册一个监听器。当Zookeeper中对应的节点数据发生变化时（例如，运维人员通过接口将`degradeSwitch`的值从`"close"`改成`"open"`），监听器会捕捉到这个变化，并实时地更新`RaffleActivityController`中`degradeSwitch`字段的值。

### 熔断
1. 添加Hystrix注解 (`@HystrixCommand`)：设置Hystrixj超时时间为150毫秒，若超过150毫秒自动失败，fallbackMethod：当方法执行超时/方法内部抛出任何未被捕获的异常/在达到一定的失败率后熔断器打开（Open），后续的所有请求都会直接调用降级方法
2. 
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTM4NDg2NzQxMSwxNjU1MDc2NjIzLDIwMj
U2ODk0MTYsLTc5NTU0MDAwLC0zNDc4NTA4MywxOTY2NzA0NDI4
LDUwNTMwOTg0LC0xMjk1NTI1MTQ3LDE1NjkxMTM3NjFdfQ==
-->