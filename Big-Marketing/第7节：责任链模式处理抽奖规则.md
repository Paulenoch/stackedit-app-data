### 一、 前置抽奖规则的运作方式

前置抽奖规则是在执行核心的随机抽奖逻辑之前，预先执行的一系列判断逻辑。根据您提供的代码，主要实现了以下三种规则处理器：

#### 1. 黑名单规则 (`BlackListLogicChain`)

这个规则是责任链的第一道防线，用于拦截黑名单中的用户。

-   **功能**：判断当前抽奖用户是否在特定策略的黑名单中。
    
-   **运作流程**：
    
    1.  当一个抽奖请求到达时，`BlackListLogicChain` 首先被触发。
        
    2.  它会根据 `strategyId` 从仓库（`repository`）中查询出此策略对应的黑名单规则配置值。这个值的格式通常是 `awardId:userId1,userId2,userId3...`。
        
    3.  代码解析这个字符串，拿到预设的奖品ID（`awardId`，通常是一个“谢谢参与”之类的安慰奖）和黑名单用户列表（`userBlackIds`）。
        
    4.  它会遍历黑名单列表，判断当前请求的 `userId` 是否在其中。
        
    5.  **处理结果**：
        
        -   **拦截 (接管)**：如果 `userId` 匹配成功，说明是黑名单用户。该责任链节点会立即返回预设的 `awardId`，整个抽奖流程到此结束。日志中会显示“抽奖责任链-黑名单接管”。
            
        -   **放行**：如果 `userId` 不在黑名单中，该节点不会处理请求，而是通过 `next().logic(userId, strategyId)` 将请求传递给责任链中的下一个节点处理。日志中会显示“抽奖责任链-黑名单放行”。
            

#### 2. 权重规则 (`RuleWeightLogicChain`)

如果用户通过了黑名单规则，请求会来到权重规则节点。这个规则用于实现“不同贡献度的用户可以参与不同奖品池”的业务场景。

-   **功能**：根据用户的某个值（例如本代码中的 `userScore`，代表用户积分），来决定用户有资格参与哪个范围的奖品抽奖。
    
-   **运作流程**：
    
    1.  此节点被触发后，会根据 `strategyId` 查询权重规则的配置值。其格式为：`4000:102,103,104 5000:102,103,104,105,106`。这表示积分达到4000的用户可以在奖品`{102, 103, 104}`中抽奖，达到5000的用户可以在奖品`{102, 103, 104, 105, 106}`中抽奖。
        
    2.  代码会解析这个配置，并获取当前用户的积分 `userScore`（在当前代码中，这个值被硬编码为0，但在实际业务中会从数据库查询）。
        
    3.  系统会用用户的积分去匹配所有规则等级，并找出用户所能达到的**最高**那个等级。例如，用户有5900积分，系统会匹配到5000这个等级。
        
    4.  **处理结果**：
        
        -   **拦截 (接管)**：如果用户的积分达到了某个等级，系统会调用 `strategyDispatch.getRandomAwardId()` 方法，但传入的参数是该等级限定的奖品范围。这意味着抽奖只会在这个特定的奖品池里进行。返回抽中的 `awardId` 后，流程结束。日志会显示“抽奖责任链-权重接管”。
            
        -   **放行**：如果用户的积分未达到任何一个配置的等级门槛，那么该节点无法处理此请求，于是通过 `next().logic()` 将请求传递给下一个节点。日志会显示“抽奖责任链-权重放行”。
            

#### 3. 默认规则 (`DefaultLogicChain`)

这是责任链的**最后一个节点**，扮演着“兜底”的角色。

-   **功能**：执行标准的、无任何前置条件的随机抽奖。
    
-   **运作流程**：
    
    -   当一个抽奖请求通过了前面所有的规则节点（例如，既不在黑名单中，积分也未达到任何权重门槛）后，最终会到达这个节点。
        
    -   `DefaultLogicChain` 会直接调用 `strategyDispatch.getRandomAwardId(strategyId)`，在当前策略的**全部奖品**中进行一次完全随机的抽奖。
        
    -   它返回抽中的 `awardId`，并且由于它是最后一个节点，它不会再向后传递请求。
        

### 二、 责任链设计模式的应用

责任链模式（Chain of Responsibility Pattern）是这套规则体系的核心。它将请求的发送者和接收者解耦，允许多个对象都有机会处理这个请求。这些对象被连接成一条链，请求沿着链传递，直到链上的某个对象处理它为止。

下面是该模式在您代码中的具体体现：

1.  **抽象处理器 (`Handler`)**:
    
    -   `ILogicChain` 接口和 `AbstractLogicChain` 抽象类共同定义了处理器的标准。
        
    -   `ILogicChain` 定义了所有处理器必须实现的 `logic` 方法。
        
    -   `AbstractLogicChain` 则提供了链接功能，它内部维护了一个 `private ILogicChain next;` 成员变量，以及 `next()` 和 `appendNext()` 方法，用于构建和遍历链条。
        
2.  **具体处理器 (`Concrete Handler`)**:
    
    -   `BlackListLogicChain`、`RuleWeightLogicChain` 和 `DefaultLogicChain` 就是具体处理器。
        
    -   每个类都实现了自己独特的 `logic` 业务逻辑。
        
    -   在 `logic` 方法的最后，如果当前处理器不“接管”请求，它就会调用 `next().logic(...)`，将请求传递给链上的下一个处理器。
        
3.  **客户端/组装者 (`Client/Assembler`)**:
    
    -   `DefaultChainFactory` 扮演了这个角色。它不直接处理请求，但它负责**构建和装配责任链**。
        
    -   `openLogicChain(strategyId)` 方法是关键。它会根据 `strategyId` 从数据库或缓存中查询出该策略配置了哪些规则（例如，`["rule_blacklist", "rule_weight"]`）。
        
    -   然后，它会从Spring容器中获取对应的规则处理器Bean（`logicChainGroup`），并按照配置的顺序，通过 `appendNext()` 方法将它们像链表一样串联起来。
        
    -   **非常重要的一点是**，工厂总是在链条的末尾自动追加上 `logicChainGroup.get("default")`，即默认处理器，确保任何请求最终都会被处理。
        

### 流程总结

一个完整的抽奖请求流程如下：

1.  外部服务调用抽奖功能，并传入 `userId` 和 `strategyId`。
    
2.  `DefaultChainFactory` 根据 `strategyId` 动态构建出一条责任链，例如：`黑名单节点 -> 权重节点 -> 默认节点`。
    
3.  请求从链头（黑名单节点）开始，调用其 `logic` 方法。
    
4.  **黑名单节点**进行判断：
    
    -   是黑名单用户 -> 返回安慰奖，流程结束。
        
    -   不是 -> 调用**权重节点**的 `logic` 方法。
        
5.  **权重节点**进行判断：
    
    -   用户积分达到某一等级 -> 在该等级的奖品池中抽奖并返回奖品，流程结束。
        
    -   积分未达到任何等级 -> 调用**默认节点**的 `logic` 方法。
        
6.  **默认节点**执行标准的抽奖逻辑，返回一个奖品，流程结束。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTMzNzQwNjA1OV19
-->