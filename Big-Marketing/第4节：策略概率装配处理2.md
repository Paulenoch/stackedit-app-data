装配由原本的策略全部装配，扩展为支持权重装配。

例子：
4000分:102,103,104,105 
5000分:102,103,104,105,106,107 
6000分:102,103,104,105,106,107,108,109

# 流程
1. 装配默认奖池（不分层）
```java
List<StrategyAwardEntity> list = repository.queryStrategyAwardList(strategyId);
assembleLotteryStrategy(String.valueOf(strategyId), list);
```
2. 判断是否配置了 `rule_weight`
```java
StrategyEntity se = repository.queryStrategyEntityByStrategyId(strategyId);
String ruleWeight = se.getRuleWeight();
if (ruleWeight == null) return true;
```
3. 读取权重规则并“裁剪奖池”
```java
StrategyRuleEntity rule = repository.queryStrategyRule(strategyId, ruleWeight);
Map<String, List<Integer>> map = rule.getRuleWeightValues(); // 例：{"4000":[102,103,...], "5000":[...], ...}
for (String key : map.keySet()) {
    List<Integer> allow = map.get(key);
    ArrayList<StrategyAwardEntity> clone = new ArrayList<>(list);
    // 只保留本层允许的奖品
    clone.removeIf(e -> !allow.contains(e.getAwardId()));
    // 以 strategyId_key 为名，分别装配
    assembleLotteryStrategy(strategyId + "_" + key, clone);
}
```
装配结果：

<!--stackedit_data:
eyJoaXN0b3J5IjpbNDA4MDg4Njg1XX0=
-->