### 为什么要引入规则树
![输入图片说明](/imgs/2025-08-14/fX2mRFbHl1McZ9Pd.png)
为解决上述场景，次数锁校验通过，但库存不足


#### 3. 核心代码结构分析

##### 3.1. 规则树的构成元素

一个完整的规则树由以下几个核心的**值对象（Value Object）**构成，这些对象通常从数据库或缓存中加载，共同描述了一棵决策树的结构：

-   **`RuleTreeVO` (规则树):** 这是整个规则树的顶层对象，定义了一棵完整的决策树。
    
    -   `treeId`: 规则树的唯一标识。
        
    -   `treeName`, `treeDesc`: 树的名称和描述。
        
    -   `treeRootRuleNode`: 根节点的`ruleKey`，指明了决策的入口。
        
    -   `treeNodeMap`: 一个 `Map<String, RuleTreeNodeVO>` 集合，存储了这棵树中所有的节点信息，以`ruleKey`作为键，方便快速查找。
        
-   **`RuleTreeNodeVO` (规则树节点):** 代表决策树中的一个具体规则节点。
    
    -   `ruleKey`: 节点的唯一标识，用于关联具体的 `ILogicTreeNode` 实现。
        
    -   `ruleValue`: 节点的规则值，例如“抽奖次数 > 5次”中的“5”。
        
    -   `treeNodeLineVOList`: 节点的出度连接线列表，定义了从当前节点到下一个节点的流转条件。
        
-   **`RuleTreeNodeLineVO` (规则树节点连接线):** 定义了节点之间的流转关系和条件。
    
    -   `ruleNodeFrom`, `ruleNodeTo`: 定义了连接的起始节点和目标节点。
        
    -   `ruleLimitType`: 限定类型，如 `EQUAL` (等于), `GT` (大于) 等。
        
    -   `ruleLimitValue`: 限定值，与 `ruleLimitType` 配合使用，判断是否满足跳转条件。例如，当 `ruleLimitType` 为 `EQUAL`，`ruleLimitValue` 为 `ALLOW` 时，表示只有当前节点返回的结果是 `ALLOW`，流程才会跳转到 `ruleNodeTo` 指定的节点。
        

##### 3.2. 规则节点的具体实现

每个规则节点都是一个 Spring Bean，并实现了 `ILogicTreeNode` 接口。`@Component` 注解的值（如 `"rule_lock"`）与 `RuleTreeNodeVO` 中的 `ruleKey` 相对应，这是工厂能够找到并注入正确节点实现的关键。

**接口定义 `ILogicTreeNode`:**

```java
// paulenoch/big-market/Paulenoch-Big-Market-8259e58a4a0bcc60ae1ce20dec427196a3a48d35/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/ILogicTreeNode.java
public interface ILogicTreeNode {
    DefaultTreeFactory.TreeActionEntity logic(String userId, Long strategyId, Integer awardId);
}
```

**实现示例 `RuleLockLogicTreeNode` (次数锁节点):**

```java
// paulenoch/big-market/Paulenoch-Big-Market-8259e58a4a0bcc60ae1ce20dec427196a3a48d35/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/impl/RuleLockLogicTreeNode.java
@Component("rule_lock")
public class RuleLockLogicTreeNode implements ILogicTreeNode {
    @Override
    public DefaultTreeFactory.TreeActionEntity logic(String userId, Long strategyId, Integer awardId) {
        // 具体的业务逻辑，例如查询用户抽奖次数
        // ...
        // 此处简化为直接放行
        return DefaultTreeFactory.TreeActionEntity.builder()
                .ruleLogicCheckType(RuleLogicCheckTypeVO.ALLOW)
                .build();
    }
}
```
logic` 方法的返回值 `TreeActionEntity` 包含了两个重要信息：
1.  `ruleLogicCheckType`: 决策结果，是 `ALLOW` (放行) 还是 `TAKE_OVER` (接管)。
2.  `strategyAwardData`: 如果当前节点能确定最终的奖励，则会携带奖励信息。

##### 3.3. 决策树引擎 `DecisionTreeEngine`

这是规则树的“大脑”，负责驱动整个决策流程。

**核心方法 `process` 的运行逻辑:**

1.  **初始化:** 从 `RuleTreeVO` 中获取根节点 `treeRootRuleNode` 作为起始节点 `nextNode`。
2.  **循环决策:**
    * 只要 `nextNode` 不为空，就进入循环。
    * 根据 `nextNode` 的 `ruleKey` 从 `logicTreeNodeGroup` (一个包含了所有规则节点实现的 `Map`) 中找到对应的 `ILogicTreeNode` 实例。
    * 执行该节点的 `logic` 方法，得到决策结果 `logicEntity`。
    * **寻找下一个节点:** 调用 `nextNode()` 方法，将 `logicEntity` 的决策结果（如 `ALLOW`）与当前节点的连接线配置 `treeNodeLineVOList`进行匹配，找出下一条要走的路径，更新 `nextNode` 的值。
3.  **结束:** 当 `nextNode` 为空时，说明决策流程结束，返回最终的 `strategyAwardData`。

```java
// paulenoch/big-market/Paulenoch-Big-Market-8259e58a4a0bcc60ae1ce20dec427196a3a48d35/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/factory/engine/impl/DecisionTreeEngine.java
public class DecisionTreeEngine implements IDecisionTreeEngine {
    // ...
    @Override
    public DefaultTreeFactory.StrategyAwardData process(String userId, Long strategyId, Integer awardId) {
        DefaultTreeFactory.StrategyAwardData strategyAwardData = null;
        String nextNode = ruleTreeVO.getTreeRootRuleNode();
        Map<String, RuleTreeNodeVO> treeNodeMap = ruleTreeVO.getTreeNodeMap();
        RuleTreeNodeVO ruleTreeNode = treeNodeMap.get(nextNode);

        while (null != nextNode) {
            ILogicTreeNode logicTreeNode = logicTreeNodeGroup.get(ruleTreeNode.getRuleKey());
            DefaultTreeFactory.TreeActionEntity logicEntity = logicTreeNode.logic(userId, strategyId, awardId);
            RuleLogicCheckTypeVO ruleLogicCheckTypeVO = logicEntity.getRuleLogicCheckType();
            strategyAwardData = logicEntity.getStrategyAwardData();
            
            nextNode = nextNode(ruleLogicCheckTypeVO.getCode(), ruleTreeNode.getTreeNodeLineVOList());
            ruleTreeNode = treeNodeMap.get(nextNode);
        }

        return strategyAwardData;
    }
    // ...
}
````

##### 3.4. 决策树工厂 `DefaultTreeFactory`

工厂类通过 Spring 的依赖注入，自动获取所有 `ILogicTreeNode` 接口的实现，并存入 `logicTreeNodeGroup` 这个 `Map` 中。

```java
// paulenoch/big-market/Paulenoch-Big-Market-8259e58a4a0bcc60ae1ce20dec427196a3a48d35/Big-Market-domain/src/main/java/com/itheima/domain/strategy/service/rule/tree/factory/DefaultTreeFactory.java
@Service
public class DefaultTreeFactory {

    private final Map<String, ILogicTreeNode> logicTreeNodeGroup;

    public DefaultTreeFactory(Map<String, ILogicTreeNode> logicTreeNodeGroup) {
        this.logicTreeNodeGroup = logicTreeNodeGroup;
    }

    public IDecisionTreeEngine openLogicTree(RuleTreeVO ruleTreeVO) {
        return new DecisionTreeEngine(logicTreeNodeGroup, ruleTreeVO);
    }
    // ...
}
```

当外部服务需要使用规则树时，只需注入 `DefaultTreeFactory`，并调用 `openLogicTree(ruleTreeVO)` 方法，即可获得一个配置好且可运行的决策引擎实例。

#### 4. 运行逻辑示例追踪

让我们通过项目中的测试用例 `LogicTreeTest` 来完整地追踪一次决策流程。

**测试中定义的规则树结构:**

-   **根节点:** `rule_lock` (次数锁)
    
-   **分支1:** 如果 `rule_lock` 返回 `TAKE_OVER` (接管)，则流转到 `rule_luck_award` (兜底奖励)。
    
-   **分支2:** 如果 `rule_lock` 返回 `ALLOW` (放行)，则流转到 `rule_stock` (库存)。
    
-   **分支3:** 如果 `rule_stock` 返回 `TAKE_OVER` (接管)，则流转到 `rule_luck_award` (兜底奖励)。
    

**执行流程:**

1.  **调用:** `treeEngine.process("xiaofuge", 100001L, 100);`
    
2.  **进入引擎:** 引擎启动，`nextNode` 被设置为根节点 `"rule_lock"`。
    
3.  **执行 `rule_lock` 节点:**
    
    -   引擎找到 `key` 为 `"rule_lock"` 的 `RuleLockLogicTreeNode` 实例。
        
    -   调用其 `logic` 方法，该方法返回 `ruleLogicCheckType = ALLOW`。
        
4.  **寻找下一节点:**
    
    -   引擎检查 `rule_lock` 节点的连接线配置。
        
    -   找到一条 `ruleLimitValue` 为 `ALLOW` 的连接线，其指向 `ruleNodeTo = "rule_stock"`。
        
    -   `nextNode` 被更新为 `"rule_stock"`。
        
5.  **执行 `rule_stock` 节点:**
    
    -   引擎找到 `key` 为 `"rule_stock"` 的 `RuleStockLogicTreeNode` 实例。
        
    -   调用其 `logic` 方法，该方法返回 `ruleLogicCheckType = TAKE_OVER`。
        
6.  **寻找下一节点:**
    
    -   引擎检查 `rule_stock` 节点的连接线配置。
        
    -   找到一条 `ruleLimitValue` 为 `TAKE_OVER` 的连接线，其指向 `ruleNodeTo = "rule_luck_award"`。
        
    -   `nextNode` 被更新为 `"rule_luck_award"`。
        
7.  **执行 `rule_luck_award` 节点:**
    
    -   引擎找到 `key` 为 `"rule_luck_award"` 的 `RuleLuckAwardLogicTreeNode` 实例。
        
    -   调用其 `logic` 方法，该方法返回最终的兜底奖励数据 `strategyAwardData`，并且没有后续节点。
        
8.  **寻找下一节点:**
    
    -   `rule_luck_award` 节点没有配置连接线，`nextNode` 方法返回 `null`。
        
9.  **结束流程:**
    
    -   `while` 循环终止。
        
    -   引擎返回 `rule_luck_award` 节点生成的 `strategyAwardData` 作为最终结果。
        

通过这个流程，我们可以看到，一个复杂的抽奖决策被清晰地分解为“次数校验”->“库存校验”->“兜底奖励”等多个步骤，并通过规则树引擎灵活地串联起来。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTEyNDk4NzA5MjIsLTcxOTU1MTMyMF19
-->