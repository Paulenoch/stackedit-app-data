![输入图片说明](/imgs/2025-02-26/zrUdggIr4s5ZnTF6.png)
Min-Heap性质：
1. 每个节点都小于等于其子节点
2. Complete：只有最底层能缺节点，所有的节点要尽可能排在左边

### 操作

 - add()：先把加入的element放在最底端，然后依次往上对比，若小于父节点则swim
 - getSmallest()：获取根节点的element
 - removeSmallest()：删除根节点后，用最右侧的节点替代根节点，然后往下对比和swim

### Tree Representation
Approach 1A：
![输入图片说明](/imgs/2025-02-26/yaqhvpdsbiBZFzi6.png)
```java
public class Tree1A<Key> {
  Key k;
  Tree1A left;
  Tree1A middle;
  Tree1A right;
  ...
}
```

Approach 1B：
![输入图片说明](/imgs/2025-02-26/eDBOaJSGesDqEYoK.png)
```java
public class Tree1B<Key> {
  Key k;
  Tree1B[] children;
  ...
}
```

Approach 1C：
![输入图片说明](/imgs/2025-02-26/kxo9jgj70U4vh5Qf.png)
```java
public class Tree1C<Key> {
  Key k;
  Tree1C favoredChild;
  Tree1C sibling;
  ...
}
```

Approach 2
![输入图片说明](/imgs/2025-02-26/I1NnziKDH0C2gwSM.png)
Key[]的index代表该element在Tree中位置，mapping对应的数据时其父节点的位置

Approach 3：
实际上int[] parents可以省略，可以直接根据index算出parent的位置，return（index-1）/2即可
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQzMDM2MTEzMywtMzMyNjExMDI2XX0=
-->