1. interface inheritance的写法
```java
public interface List61B<Item> {
    public void addFirst(Item x);
    public void add Last(Item y);
    public Item getFirst();
    public Item getLast();
    public Item removeLast();
    public Item get(int i);
    public void insert(Item x, int position);
    public int size();
}
```
```java
public class AList<Item> implements List61B<Item>{...}
```
_______________________
2. 在子类override的方法前添加`@Override` tag进行标记
_______________________
3. 
```java
	public static void main(String[] args) {
	    List61B<String> someList = new SLList<String>();
	    someList.addFirst("elk");
	}
```
可以将子类的地址传递给父类，因为子类属于父类
_______________________
4. 可以在interface中进行implementation Inheritance
```java
default public void print() {
    for (int i = 0; i < size(); i += 1) {
        System.out.print(get(i) + " ");
    }
    System.out.println();
}
```
   所有的子类都可以使用该方法
_______________________
5. 如果不想使用父类的方法，可以override
```java
@Override
public void print() {
    for (Node p = sentinel.next; p != null; p = p.next) {
        System.out.print(p.item + " ");
    }
}
```
_______________________
6. 当遇到如下情况，实际调用的是SLList的print方法
```java
List61b<String> somelist = new SLList<String>();
someList.print();
```
事实上，List61b在此处是static tyoe，指变量在**编译时**的类型，它由变量声明时的类型决定，且在编译时就已经确定。
而SLList在此处是dynamic type，指变量在**运行时**实际指向的对象的类型。它由运行时实际分配的对象决定。动态类型决定了在运行时调用哪个方法（如果方法被重写）。
-   静态类型决定了**可以调用哪些方法**（编译时检查）。
    
-   动态类型决定了**实际调用哪个方法**（运行时决定）。
_______________________
7. Override VS Overload

`Override` 是指子类重新定义父类中已经存在的方法。重写的方法必须与父类方法具有相同的**方法签名**（方法名、参数列表）和**返回类型**。

`Overload` 是指在同一个类中定义多个方法，它们具有相同的**方法名**，但**参数列表不同**（参数类型、参数数量或参数顺序）。重载与返回值类型无关。

8. 注意，只有在override的情况下存在dynamic method selection，当是overload的情况时，编译器会根据static type选择method，SP的输出是elk，LP的输出是cool
```java
public static void peek(List61B<String> list) {
    System.out.println(list.getLast());
}
public static void peek(SLList<String> list) {
    System.out.println(list.getFirst());
}

SLList<String> SP = new SLList<String>();
List61B<String> LP = SP;
SP.addLast("elk");
SP.addLast("are");
SP.addLast("cool");
peek(SP);
peek(LP);
```
_______________________
8. 不允许直接将父类引用赋值给子类引用
```java
public class TestAnimals {  
    public static void main(String[] args) {  
        Animal a = new Animal("Pluto", 10);   
        Dog d = new Dog("Fido", 4);   
        a = new Dog("Spot", 10);  
        d = a;  
    }  
}
```
a是Animal类型的引用，d是Dog类型的引用，所以d = a编译无法通过
<!--stackedit_data:
eyJoaXN0b3J5IjpbMjc5MTc5NDgxLC0xMjA4NTg3NjM3LDExND
MwNzUzNTIsLTE0MjI0MjI0ODgsLTQ1MjIzOTM4MSwyMDIzNjM2
NjYyLC0yNjQ2NDkyNjMsLTQ2OTQ1MzU0XX0=
-->