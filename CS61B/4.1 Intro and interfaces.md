1. interface inheritance的写法
```java
public interface List61B<Item> {
    public void addFirst(Item x);
    public void add Last(Item y);
    public Item getFirst();
    public Item getLast();
    public Item removeLast();
    public Item get(int i);
    public void insert(Item x, int position);
    public int size();
}
```
```java
public class AList<Item> implements List61B<Item>{...}
```

2. 在子类override的方法前添加`@Override` tag进行标记

3. 
```java
	public static void main(String[] args) {
	    List61B<String> someList = new SLList<String>();
	    someList.addFirst("elk");
	}
```
可以将子类的地址传递给父类，因为子类属于父类

4. 可以在interface中进行implementation Inheritance
```java
default public void print() {
    for (int i = 0; i < size(); i += 1) {
        System.out.print(get(i) + " ");
    }
    System.out.println();
}
```
   所有的子类都可以使用该方法

5. 如果不想使用父类的方法，可以override
```java
@Override
public void print() {
    for (Node p = sentinel.next; p != null; p = p.next) {
        System.out.print(p.item + " ");
    }
}
```

6. 当遇到如下情况，实际调用的是SLList的print方法
```java
List61b<String> somelist = new SLList<String>();
someList.print();
```
事实上，List61b在此处是static tyoe，指变量在**编译时**的类型，它由变量声明时的类型决定，且在编译时就已经确定。
而SLList在此处是dynamic type，指变量在**运行时**实际指向的对象的类型。它由运行时实际分配的对象决定。动态类型决定了在运行时调用哪个方法（如果方法被重写）。
-   静态类型决定了**可以调用哪些方法**（编译时检查）。
    
-   动态类型决定了**实际调用哪个方法**（运行时决定）。

7. Ovr

### **定义**

`Override` 是指子类重新定义父类中已经存在的方法。重写的方法必须与父类方法具有相同的**方法签名**（方法名、参数列表）和**返回类型**。
## **Overload（重载）**

### **定义**

`Overload` 是指在同一个类中定义多个方法，它们具有相同的**方法名**，但**参数列表不同**（参数类型、参数数量或参数顺序）。重载与返回值类型无关。
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU3OTc5NjAyNywtMTQyMjQyMjQ4OCwtND
UyMjM5MzgxLDIwMjM2MzY2NjIsLTI2NDY0OTI2MywtNDY5NDUz
NTRdfQ==
-->