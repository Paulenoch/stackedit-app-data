![输入图片说明](/imgs/2025-02-28/1HVVVHOZvVO0EbiG.png)

最短路径会形成一棵树，树的edges = vertices - 1

#### **算法目的**

在**带非负权重的有向图**中找到从**单源点**到所有其他顶点的**最短路径**。

----------

#### **算法步骤**

1.  **初始化**：
    
    -   优先队列（PQ）中放入源点，距离为`0`；其他顶点初始距离设为`∞`。
        
2.  **循环处理优先队列**：
    
    -   取出当前距离最小的顶点 `p`（即 `PQ.removeSmallest()`）。
        
    -   对 `p` 的所有邻边执行**松弛操作**。
        
3.  **终止条件**：
    
    -   当优先队列为空时，算法结束。
        

----------

#### **关键数据结构**

-   **`distTo[v]`**：记录从源点到顶点 `v` 的最短距离。
    
-   **`edgeTo[v]`**：记录顶点 `v` 在最短路径上的前驱节点。
    
-   **优先队列（PQ）**：按 `distTo` 值升序排列所有**未访问的顶点**。
    

----------

#### **松弛操作（Relaxation）**

对边 `p → q`（权重为 `w`）执行以下操作：

1.  **条件检查**：
    
    -   若 `distTo[p] + w < distTo[q]`，说明发现更短路径。
        
2.  **更新操作**：
    
    -   更新 `distTo[q] = distTo[p] + w`。
        
    -   更新 `edgeTo[q] = p`。
        
    -   调整优先队列中 `q` 的优先级（`PQ.changePriority(q, distTo[q]`）。
        

----------

#### **关键不变量**

1.  **最优性保证**：
    
    -   `distTo[v]` 始终是当前已知的源点到 `v` 的最短距离。
        
    -   `edgeTo[v]` 始终是当前已知的最优前驱节点。
        
2.  **队列性质**：
    
    -   优先队列中的顶点按 `distTo` 升序排列。
        

----------

#### **重要性质**

1.  **顶点访问顺序**：
    
    -   顶点按**距离源点的总距离递增**顺序被访问。
        
2.  **已访问顶点不再更新**：
    
    -   松弛操作对已移出队列（标记为已访问）的顶点**必定失败**，因为其最短路径已确定。
        

----------

#### **适用条件与注意事项**

-   **非负权重**：算法仅适用于边权重非负的图，负权边会导致错误结果。
    
-   **时间复杂度**：
    
    -   使用二叉堆：`O((V+E) log V)`
        
    -   使用数组：`O(V²)`（适合稠密图）
        
-   **路径重建**：通过 `edgeTo` 数组从目标顶点回溯到源点，即可得到最短路径。
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE0MDYyMDU0NTIsLTI4MjczODM3MV19
-->