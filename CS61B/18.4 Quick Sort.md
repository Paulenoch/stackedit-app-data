对于一个数列，选择一个element作为pivot，将比pivot大的element放在pivot右边，将比pivot小的element放在pivot左边

对pivot左右两端的partition数列继续使用quick sort，直到所有partition只包含一个element为止

![输入图片说明](/imgs/2025-03-03/F7VNEC234eWarMLQ.png)
但实际上Quicksort很难出现worstcase，best case指的是每次选取的pivot正好落在数列中间，而worst case指的是每次选取的pivot位置不变（一直在最前面or最后面）

即使每次pivot都落在数列的前10%区域（概率很小，0.1^N），时间复杂度仍为O(NlogN)

Quicksort is BST Sort
This is because the compareTo calls that Quicksort employs between each element and the pivot element in each partition is the same as the compareTo calls performed in BST insert.
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE4MDY5ODYxMTJdfQ==
-->