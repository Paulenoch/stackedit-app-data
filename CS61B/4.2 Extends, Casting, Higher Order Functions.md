1. extends继承父类的时候会继承
-   All instance and static variables
-   All methods
-   All nested classes
- 不会继承constructor
- private methods不可被子类调用
_______________________
2. super调用父类的方法：
```java
@Override  
public Item removeLast() {  
    Item x = super.removeLast();  
    deletedItems.addLast(x);  
    return x;  
}
```
_______________________
3. 若无手动设置，子类的constructor会自动调用父类默认的constructor
```java
public VengefulSLList() {
    super(); //可以省略
    deletedItems = new SLList<Item>();
}
```
需注意如下情况
```java
public VengefulSLList(Item x) {
    super(x);//若省略该行，则会自动调用super()，出现错误
    deletedItems = new SLList<Item>();
}
```
_______________________
4. 所有类，若无特殊extends指定，默认继承Object，重要方法：`.equals(Object obj)`, `.hashCode()`, and `toString()`
	interface不继承Object
_______________________
5. implementation inheritance可能会破坏类的封装
Dog类包含两个method
```java
public void bark() {
    barkMany(1);
}

public void barkMany(int N) {
    for (int i = 0; i < N; i += 1) {
        System.out.println("bark");
    }
}
```
Verbose Dog类继承Dog类并override barkMany method
```java
@Override
public void barkMany(int N) {
    System.out.println("As a dog, I say: ");
    for (int i = 0; i < N; i += 1) {
        bark();
    }
}
```
此时定义一只VerboseDog `vd`, 调用 `vd.barkMany(3)` ，因为vd的动态类型是VerboseDog所以调用Override的barkMany method，在该method中调用bark()，由于Verbose Dog中不包含bark()方法于是调用父类的bark()方法，Dog的bark()方法中调用barkMany(1)，此时由于动态类型依旧是VerboseDog所以会再次调用Override的barkMany method，进入死循环
___
6. 类似这种定义是可行的，因为vsl的类型是VengefulSLList，而VengefulSLList is a SLList
```java
VengefulSLList<Integer> vsl = new VengefulSLList<Integer>(9);
SLList<Integer> sl = vsl;
```
```java
VengefulSLList<Integer> vsl2 = sl;
```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI1MzEzMjkzNywtMTIwNDAxNDQyNywtND
U0NTg3MTUyLC05NTE2NDc0NjEsLTcyODUzODc1XX0=
-->