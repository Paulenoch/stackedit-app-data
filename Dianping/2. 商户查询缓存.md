## 1. 更新策略
低一致性需求：使用内存淘汰机制，如店铺类型查询缓存
高一致性需求：主动更新，并以超时剔除作为兜底方案，如店铺详情查询的缓存

## 2. 主动更新策略：
1. Cache Aside Pattern: 由缓存的调用者，在更新数据库的同时更新缓存
2. Read/Write Through Pattern: 缓存与数据库整合为一个服务，由服务维护一致性，调用者无需关心缓存一致性问题
3. Write Behinid Caching Pattern:  调用者只cao'zuo'huan'cun
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgzODkyNzQ5MF19
-->