## 1. 更新策略
低一致性需求：使用内存淘汰机制，如店铺类型查询缓存
高一致性需求：主动更新，并以超时剔除作为兜底方案，如店铺详情查询的缓存

## 2. 主动更新策略：
1. Cache Aside Pattern: 由缓存的调用者，在更新数据库的同时更新缓存
2. Read/Write Through Pattern: 缓存与数据库整合为一个服务，由服务维护一致性，调用者无需关心缓存一致性问题
3. Write Behinid Caching Pattern:  调用者只操作缓存，由其他线程异步将缓存数据持久化到数据库，保证最终一致

## 3. 线程安全问题
对于写操作：先写数据库，在删除缓存，确保数据库与缓存操作的原子性
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI2OTAxMzQ0MCw4MzY2NjkyNTZdfQ==
-->