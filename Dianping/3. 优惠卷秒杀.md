## 全局ID生成器
订单表中的数据不能使用数据库自增id：
- id的规律太明显，会把信息暴露给用户
- 收到单表数据量的限制

全局ID生成器：一种用在分布式系统下用来生成全局唯一ID的工具
基于redis实现：不能直接使用redis自增的数值，需要拼接其他信息
符号位（0）+时间戳（31bit，以秒为单位）+序列号（32bit，每秒可产生2^32个不同的id）

## 超卖问题
用乐观锁解决，下单时检查库存是否大于0
```java
//5.扣减库存  
boolean success = seckillVoucherService.update()  
        .setSql("stock = stock - 1")  
        .eq("voucher_id", voucherId).gt("stock", 0)  
        .update();  
if (!success) {  
    return Result.fail("库存不足");  
}
```

## 一人一单
初步方案：下单时去数据库里查询该用户id和优惠卷id对应的订单是否存在，若存在则下单失败，此时仍存在多线程安全问题

若直接对createVoucherOrder()方法加synchronized，锁的粒度太粗，同时只能有一个用户下单，希望达到的效果是每个用户都能同时下单，对每个用户加锁

所以在方法内加锁`synchronized(userId.toString().intern())`，这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法

但是以上方法还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：

```java
synchronized(userId.toString().intern()) {  
    //获取代理对象（事务）  
    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
    //8.返回订单id  
    return proxy.createVoucherOrder(voucherId);  
}
```
以上代码若不获取代理对象，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务

## 分布式锁
以上方案只适用于单体服务，此时只有一个JVM环境，若部署为分布式服务，各个JVM环境中的synchronized锁不是同一把，此时锁的效果在不同的服务器之间无法共享，需要设计一个JVM环境外的锁，可以被所有JVM环境观测到

基于Redis实现分布式锁：利用SETNX，为防止系统崩溃后设置了的锁无法得到释放形成死锁，给锁加上超时时间，到期释放

### redis分布式锁超时释放锁误删问题
在获取锁时存入线程标示（可以用UUID表示） 在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致

-   如果一致则释放锁
    
-   如果不一致则不释放锁

-   使用Lua脚本执行多条命令原子性问题

### Redission可重入锁原理
methodA中获取了锁，methodA调用methodB，此时methodB试图获取同一把锁，若能获取，即为可重入锁
原理：用Hash结构存储锁，key为锁的名称，field为获取锁的线程名，value为获取锁的次数，每当有线程试图获取锁，对比线程名是否一致，若一致则获取锁且value+1，每次释放锁也先对比线程名是否一致，value-1，若value为0则删除锁

![输入图片说明](/imgs/2025-04-06/XmHWWNF2QQLFnbMk.png)

可重试：利用信号量和PubSub功能实现，获取所失败后订阅信号，当释放锁的信号被捕获到后再次尝试获取锁（未过期的情况下）
超时续约：
1.  **初始加锁**：当客户端成功获取锁时，Redisson 会在 Redis 中设置一个键，并设置一个默认的过期时间(默认30秒)
    
2.  **看门狗线程**：在获取锁成功后，Redisson 会启动一个后台定时任务(看门狗线程)，定期检查客户端是否还持有该锁
    
3.  **续约机制**：如果客户端仍然持有锁，看门狗线程会定期(默认每10秒)延长锁的过期时间，重置为初始的超时时间(默认30秒)
    
4.  **自动释放**：如果客户端崩溃或无法续约，锁最终会因超时而被自动释放

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTQxMDI1ODAxMSw3ODAxNDkzNDYsMTI4OD
AwMjI0NCwxNTEzNzMwNDEsODAxMzgxMSwxNTExMzgxNjIyLC00
NzQ5NzQyNywxNzg0MDI1ODIwLC0xNjUzMDM0NDFdfQ==
-->