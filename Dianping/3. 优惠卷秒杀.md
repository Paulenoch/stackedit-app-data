## 全局ID生成器
订单表中的数据不能使用数据库自增id：
- id的规律太明显，会把信息暴露给用户
- 收到单表数据量的限制

全局ID生成器：一种用在分布式系统下用来生成全局唯一ID的工具
基于redis实现：不能直接使用redis自增的数值，需要拼接其他信息
符号位（0）+时间戳（31bit，以秒为单位）+序列号（32bit，每秒可产生2^32个不同的id）

## 超卖问题
用乐观锁解决，下单时检查库存是否大于0
```java
//5.扣减库存  
boolean success = seckillVoucherService.update()  
        .setSql("stock = stock - 1")  
        .eq("voucher_id", voucherId).gt("stock", 0)  
        .update();  
if (!success) {  
    return Result.fail("库存不足");  
}
```

## 一人一单
初步方案：下单时去数据库里查询该用户id和优惠卷id对应的订单是否存在，若存在则下单失败，此时仍存在多线程安全问题

若直接对createVoucherOrder()方法加synchronized，锁的粒度太粗，同时只能有一个用户下单，希望达到的效果是每个用户都能同时下单，对每个用户加锁

所以在方法内加锁`synchronized(userId.toString().intern())`，这个方法是从常量池中拿到数据，如果我们直接使用userId.toString() 他拿到的对象实际上是不同的对象，new出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用intern()方法

但是以上方法还是存在问题，问题的原因在于当前方法被spring的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题：如下：

```java
synchronized(userId.toString().intern()) {  
    //获取代理对象（事务）  
    IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();  
    //8.返回订单id  
    return proxy.createVoucherOrder(voucherId);  
}
```
但是以上做法依然有问题，因为你调用的方法，其实是this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象， 来操作事务
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTI3NTc4NTY1LC00NzQ5NzQyNywxNzg0MD
I1ODIwLC0xNjUzMDM0NDFdfQ==
-->