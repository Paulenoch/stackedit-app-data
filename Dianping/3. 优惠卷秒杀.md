## 全局ID生成器
订单表中的数据不能使用数据库自增id：
- id的规律太明显，会把信息暴露给用户
- 收到单表数据量的限制

全局ID生成器：一种用在分布式系统下用来生成全局唯一ID的工具
基于redis实现：不能直接使用redis自增的数值，需要拼接其他信息
符号位（0）+时间戳（31bit，以秒为单位）+序列号（32bit，每秒可产生2^32个不同的id）

## 超卖问题
用乐观锁解决，下单时检查库存是否大于0
```java
//5.扣减库存  
boolean success = seckillVoucherService.update()  
        .setSql("stock = stock - 1")  
        .eq("voucher_id", voucherId).gt("stock", 0)  
        .update();  
if (!success) {  
    return Result.fail("库存不足");  
}
```

## 一人一单
初步方案：下单时去数据库里查询该用户id和优惠卷id对应的订单是否存在，若存在则下单失败，此时仍存在多线程安全问题

若直接对createVoucherOrder()方法加synchronized，锁的粒度太粗，同时只能有一个用户下单，希望达到的效果是每个用户都能同时下单，对每个用户加锁

所以在方法内添加`synchronized(userId.toString().intern())`
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE1NDY0MjY2NiwtNDc0OTc0MjcsMTc4ND
AyNTgyMCwtMTY1MzAzNDQxXX0=
-->